/* eslint-disable */



const peggyParser: {parse: any, SyntaxError: any, DefaultTracer?: any} = // Generated by Peggy 3.0.2.
//
// https://peggyjs.org/
// @ts-ignore
(function() {
// @ts-ignore
  "use strict";

// @ts-ignore
function peg$subclass(child, parent) {
// @ts-ignore
  function C() { this.constructor = child; }
// @ts-ignore
  C.prototype = parent.prototype;
// @ts-ignore
  child.prototype = new C();
}

// @ts-ignore
function peg$SyntaxError(message, expected, found, location) {
// @ts-ignore
  var self = Error.call(this, message);
  // istanbul ignore next Check is a necessary evil to support older environments
// @ts-ignore
  if (Object.setPrototypeOf) {
// @ts-ignore
    Object.setPrototypeOf(self, peg$SyntaxError.prototype);
  }
// @ts-ignore
  self.expected = expected;
// @ts-ignore
  self.found = found;
// @ts-ignore
  self.location = location;
// @ts-ignore
  self.name = "SyntaxError";
// @ts-ignore
  return self;
}

// @ts-ignore
peg$subclass(peg$SyntaxError, Error);

// @ts-ignore
function peg$padEnd(str, targetLength, padString) {
// @ts-ignore
  padString = padString || " ";
// @ts-ignore
  if (str.length > targetLength) { return str; }
// @ts-ignore
  targetLength -= str.length;
// @ts-ignore
  padString += padString.repeat(targetLength);
// @ts-ignore
  return str + padString.slice(0, targetLength);
}

// @ts-ignore
peg$SyntaxError.prototype.format = function(sources) {
// @ts-ignore
  var str = "Error: " + this.message;
// @ts-ignore
  if (this.location) {
// @ts-ignore
    var src = null;
// @ts-ignore
    var k;
// @ts-ignore
    for (k = 0; k < sources.length; k++) {
// @ts-ignore
      if (sources[k].source === this.location.source) {
// @ts-ignore
        src = sources[k].text.split(/\r\n|\n|\r/g);
// @ts-ignore
        break;
      }
    }
// @ts-ignore
    var s = this.location.start;
// @ts-ignore
    var offset_s = (this.location.source && (typeof this.location.source.offset === "function"))
// @ts-ignore
      ? this.location.source.offset(s)
// @ts-ignore
      : s;
// @ts-ignore
    var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
// @ts-ignore
    if (src) {
// @ts-ignore
      var e = this.location.end;
// @ts-ignore
      var filler = peg$padEnd("", offset_s.line.toString().length, ' ');
// @ts-ignore
      var line = src[s.line - 1];
// @ts-ignore
      var last = s.line === e.line ? e.column : line.length + 1;
// @ts-ignore
      var hatLen = (last - s.column) || 1;
// @ts-ignore
      str += "\n --> " + loc + "\n"
// @ts-ignore
          + filler + " |\n"
// @ts-ignore
          + offset_s.line + " | " + line + "\n"
// @ts-ignore
          + filler + " | " + peg$padEnd("", s.column - 1, ' ')
// @ts-ignore
          + peg$padEnd("", hatLen, "^");
// @ts-ignore
    } else {
// @ts-ignore
      str += "\n at " + loc;
    }
  }
// @ts-ignore
  return str;
};

// @ts-ignore
peg$SyntaxError.buildMessage = function(expected, found) {
// @ts-ignore
  var DESCRIBE_EXPECTATION_FNS = {
// @ts-ignore
    literal: function(expectation) {
// @ts-ignore
      return "\"" + literalEscape(expectation.text) + "\"";
    },

// @ts-ignore
    class: function(expectation) {
// @ts-ignore
      var escapedParts = expectation.parts.map(function(part) {
// @ts-ignore
        return Array.isArray(part)
// @ts-ignore
          ? classEscape(part[0]) + "-" + classEscape(part[1])
// @ts-ignore
          : classEscape(part);
      });

// @ts-ignore
      return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
    },

// @ts-ignore
    any: function() {
// @ts-ignore
      return "any character";
    },

// @ts-ignore
    end: function() {
// @ts-ignore
      return "end of input";
    },

// @ts-ignore
    other: function(expectation) {
// @ts-ignore
      return expectation.description;
    }
  };

// @ts-ignore
  function hex(ch) {
// @ts-ignore
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

// @ts-ignore
  function literalEscape(s) {
// @ts-ignore
    return s
// @ts-ignore
      .replace(/\\/g, "\\\\")
// @ts-ignore
      .replace(/"/g,  "\\\"")
// @ts-ignore
      .replace(/\0/g, "\\0")
// @ts-ignore
      .replace(/\t/g, "\\t")
// @ts-ignore
      .replace(/\n/g, "\\n")
// @ts-ignore
      .replace(/\r/g, "\\r")
// @ts-ignore
      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
// @ts-ignore
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
  }

// @ts-ignore
  function classEscape(s) {
// @ts-ignore
    return s
// @ts-ignore
      .replace(/\\/g, "\\\\")
// @ts-ignore
      .replace(/\]/g, "\\]")
// @ts-ignore
      .replace(/\^/g, "\\^")
// @ts-ignore
      .replace(/-/g,  "\\-")
// @ts-ignore
      .replace(/\0/g, "\\0")
// @ts-ignore
      .replace(/\t/g, "\\t")
// @ts-ignore
      .replace(/\n/g, "\\n")
// @ts-ignore
      .replace(/\r/g, "\\r")
// @ts-ignore
      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
// @ts-ignore
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
  }

// @ts-ignore
  function describeExpectation(expectation) {
// @ts-ignore
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

// @ts-ignore
  function describeExpected(expected) {
// @ts-ignore
    var descriptions = expected.map(describeExpectation);
// @ts-ignore
    var i, j;

// @ts-ignore
    descriptions.sort();

// @ts-ignore
    if (descriptions.length > 0) {
// @ts-ignore
      for (i = 1, j = 1; i < descriptions.length; i++) {
// @ts-ignore
        if (descriptions[i - 1] !== descriptions[i]) {
// @ts-ignore
          descriptions[j] = descriptions[i];
// @ts-ignore
          j++;
        }
      }
// @ts-ignore
      descriptions.length = j;
    }

// @ts-ignore
    switch (descriptions.length) {
// @ts-ignore
      case 1:
// @ts-ignore
        return descriptions[0];

// @ts-ignore
      case 2:
// @ts-ignore
        return descriptions[0] + " or " + descriptions[1];

// @ts-ignore
      default:
// @ts-ignore
        return descriptions.slice(0, -1).join(", ")
// @ts-ignore
          + ", or "
// @ts-ignore
          + descriptions[descriptions.length - 1];
    }
  }

// @ts-ignore
  function describeFound(found) {
// @ts-ignore
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

// @ts-ignore
  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

// @ts-ignore
function peg$DefaultTracer() {
// @ts-ignore
  this.indentLevel = 0;
}

// @ts-ignore
peg$DefaultTracer.prototype.trace = function(event) {
// @ts-ignore
  var that = this;

// @ts-ignore
  function log(event) {
// @ts-ignore
    function repeat(string, n) {
// @ts-ignore
       var result = "", i;

// @ts-ignore
       for (i = 0; i < n; i++) {
// @ts-ignore
         result += string;
       }

// @ts-ignore
       return result;
    }

// @ts-ignore
    function pad(string, length) {
// @ts-ignore
      return string + repeat(" ", length - string.length);
    }

// @ts-ignore
    if (typeof console === "object") {
// @ts-ignore
      console.log(
// @ts-ignore
        event.location.start.line + ":" + event.location.start.column + "-"
// @ts-ignore
          + event.location.end.line + ":" + event.location.end.column + " "
// @ts-ignore
          + pad(event.type, 10) + " "
// @ts-ignore
          + repeat("  ", that.indentLevel) + event.rule
      );
    }
  }

// @ts-ignore
  switch (event.type) {
// @ts-ignore
    case "rule.enter":
// @ts-ignore
      log(event);
// @ts-ignore
      this.indentLevel++;
// @ts-ignore
      break;

// @ts-ignore
    case "rule.match":
// @ts-ignore
      this.indentLevel--;
// @ts-ignore
      log(event);
// @ts-ignore
      break;

// @ts-ignore
    case "rule.fail":
// @ts-ignore
      this.indentLevel--;
// @ts-ignore
      log(event);
// @ts-ignore
      break;

// @ts-ignore
    default:
// @ts-ignore
      throw new Error("Invalid event type: " + event.type + ".");
  }
};

// @ts-ignore
function peg$parse(input, options) {
// @ts-ignore
  options = options !== undefined ? options : {};

// @ts-ignore
  var peg$FAILED = {};
// @ts-ignore
  var peg$source = options.grammarSource;

// @ts-ignore
  var peg$startRuleFunctions = { query_statement: peg$parsequery_statement };
// @ts-ignore
  var peg$startRuleFunction = peg$parsequery_statement;

// @ts-ignore
  var peg$c0 = "*";
  var peg$c1 = "a.ary";
  var peg$c2 = "[1,2,3]";
  var peg$c3 = "SUM(sales)";
  var peg$c4 = "col";
  var peg$c5 = "'Q1'";
  var peg$c6 = "(a,(b,c),d)";
  var peg$c7 = "ROLLUP(a,b,c)";
  var peg$c8 = "(a,b,c)";
  var peg$c9 = "window_name";
  var peg$c10 = "epsilon";
  var peg$c11 = "delta";
  var peg$c12 = "max_groups_contributed";
  var peg$c13 = "privacy_unit_column";
  var peg$c14 = "1";
  var peg$c15 = "true";
  var peg$c16 = "and";
  var peg$c17 = "all";
  var peg$c18 = "as";
  var peg$c19 = "asc";
  var peg$c20 = "between";
  var peg$c21 = "by";
  var peg$c22 = "current";
  var peg$c23 = "cross";
  var peg$c24 = "desc";
  var peg$c25 = "differential_privacy";
  var peg$c26 = "distinct";
  var peg$c27 = "except";
  var peg$c28 = "exclude";
  var peg$c29 = "for";
  var peg$c30 = "following";
  var peg$c31 = "from";
  var peg$c32 = "full";
  var peg$c33 = "group";
  var peg$c34 = "having";
  var peg$c35 = "in";
  var peg$c36 = "include";
  var peg$c37 = "inner";
  var peg$c38 = "intersect";
  var peg$c39 = "join";
  var peg$c40 = "left";
  var peg$c41 = "limit";
  var peg$c42 = "nulls";
  var peg$c43 = "of";
  var peg$c44 = "offset";
  var peg$c45 = "on";
  var peg$c46 = "options";
  var peg$c47 = "order";
  var peg$c48 = "outer";
  var peg$c49 = "partition";
  var peg$c50 = "percent";
  var peg$c51 = "preceding";
  var peg$c52 = "pivot";
  var peg$c53 = "qualify";
  var peg$c54 = "range";
  var peg$c55 = "recursive";
  var peg$c56 = "replace";
  var peg$c57 = "row";
  var peg$c58 = "rows";
  var peg$c59 = "right";
  var peg$c60 = "select";
  var peg$c61 = "struct";
  var peg$c62 = "system";
  var peg$c63 = "system_time";
  var peg$c64 = "tablesample";
  var peg$c65 = "unbounded";
  var peg$c66 = "union";
  var peg$c67 = "unnest";
  var peg$c68 = "unpivot";
  var peg$c69 = "using";
  var peg$c70 = "value";
  var peg$c71 = "where";
  var peg$c72 = "window";
  var peg$c73 = "with";
  var peg$c74 = "(";
  var peg$c75 = ")";
  var peg$c76 = "()";
  var peg$c77 = "=";
  var peg$c78 = ",";
  var peg$c79 = ".";

  var peg$r0 = /^[a-zA-Z.]/;
  var peg$r1 = /^[a-zA-Z]/;
  var peg$r2 = /^[0-9]/;
  var peg$r3 = /^[ \t\n\r]/;

  var peg$e0 = peg$literalExpectation("*", false);
  var peg$e1 = peg$classExpectation([["a", "z"], ["A", "Z"], "."], false, false);
  var peg$e2 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
  var peg$e3 = peg$literalExpectation("a.ary", false);
  var peg$e4 = peg$literalExpectation("[1,2,3]", false);
  var peg$e5 = peg$literalExpectation("SUM(sales)", false);
  var peg$e6 = peg$literalExpectation("col", false);
  var peg$e7 = peg$literalExpectation("'Q1'", false);
  var peg$e8 = peg$classExpectation([["0", "9"]], false, false);
  var peg$e9 = peg$literalExpectation("(a,(b,c),d)", false);
  var peg$e10 = peg$literalExpectation("ROLLUP(a,b,c)", false);
  var peg$e11 = peg$literalExpectation("(a,b,c)", false);
  var peg$e12 = peg$literalExpectation("window_name", false);
  var peg$e13 = peg$literalExpectation("epsilon", false);
  var peg$e14 = peg$literalExpectation("delta", false);
  var peg$e15 = peg$literalExpectation("max_groups_contributed", false);
  var peg$e16 = peg$literalExpectation("privacy_unit_column", false);
  var peg$e17 = peg$literalExpectation("1", true);
  var peg$e18 = peg$literalExpectation("true", true);
  var peg$e19 = peg$otherExpectation("WHITESPACE");
  var peg$e20 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false);
  var peg$e21 = peg$literalExpectation("AND", true);
  var peg$e22 = peg$literalExpectation("ALL", true);
  var peg$e23 = peg$literalExpectation("AS", true);
  var peg$e24 = peg$literalExpectation("ASC", true);
  var peg$e25 = peg$literalExpectation("BETWEEN", true);
  var peg$e26 = peg$literalExpectation("BY", true);
  var peg$e27 = peg$literalExpectation("CURRENT", true);
  var peg$e28 = peg$literalExpectation("CROSS", true);
  var peg$e29 = peg$literalExpectation("DESC", true);
  var peg$e30 = peg$literalExpectation("DIFFERENTIAL_PRIVACY", true);
  var peg$e31 = peg$literalExpectation("DISTINCT", true);
  var peg$e32 = peg$literalExpectation("EXCEPT", true);
  var peg$e33 = peg$literalExpectation("EXCLUDE", true);
  var peg$e34 = peg$literalExpectation("FOR", true);
  var peg$e35 = peg$literalExpectation("FOLLOWING", true);
  var peg$e36 = peg$literalExpectation("FROM", true);
  var peg$e37 = peg$literalExpectation("FULL", true);
  var peg$e38 = peg$literalExpectation("GROUP", true);
  var peg$e39 = peg$literalExpectation("HAVING", true);
  var peg$e40 = peg$literalExpectation("IN", true);
  var peg$e41 = peg$literalExpectation("INCLUDE", true);
  var peg$e42 = peg$literalExpectation("INNER", true);
  var peg$e43 = peg$literalExpectation("INTERSECT", true);
  var peg$e44 = peg$literalExpectation("JOIN", true);
  var peg$e45 = peg$literalExpectation("LEFT", true);
  var peg$e46 = peg$literalExpectation("LIMIT", true);
  var peg$e47 = peg$literalExpectation("NULLS", true);
  var peg$e48 = peg$literalExpectation("OF", true);
  var peg$e49 = peg$literalExpectation("OFFSET", true);
  var peg$e50 = peg$literalExpectation("ON", true);
  var peg$e51 = peg$literalExpectation("OPTIONS", true);
  var peg$e52 = peg$literalExpectation("ORDER", true);
  var peg$e53 = peg$literalExpectation("OUTER", true);
  var peg$e54 = peg$literalExpectation("PARTITION", true);
  var peg$e55 = peg$literalExpectation("PERCENT", true);
  var peg$e56 = peg$literalExpectation("PRECEDING", true);
  var peg$e57 = peg$literalExpectation("PIVOT", true);
  var peg$e58 = peg$literalExpectation("QUALIFY", true);
  var peg$e59 = peg$literalExpectation("RANGE", true);
  var peg$e60 = peg$literalExpectation("RECURSIVE", true);
  var peg$e61 = peg$literalExpectation("REPLACE", true);
  var peg$e62 = peg$literalExpectation("ROW", true);
  var peg$e63 = peg$literalExpectation("ROWS", true);
  var peg$e64 = peg$literalExpectation("RIGHT", true);
  var peg$e65 = peg$literalExpectation("SELECT", true);
  var peg$e66 = peg$literalExpectation("STRUCT", true);
  var peg$e67 = peg$literalExpectation("SYSTEM", true);
  var peg$e68 = peg$literalExpectation("SYSTEM_TIME", true);
  var peg$e69 = peg$literalExpectation("TABLESAMPLE", true);
  var peg$e70 = peg$literalExpectation("UNBOUNDED", true);
  var peg$e71 = peg$literalExpectation("UNION", true);
  var peg$e72 = peg$literalExpectation("UNNEST", true);
  var peg$e73 = peg$literalExpectation("UNPIVOT", true);
  var peg$e74 = peg$literalExpectation("USING", true);
  var peg$e75 = peg$literalExpectation("VALUE", true);
  var peg$e76 = peg$literalExpectation("WHERE", true);
  var peg$e77 = peg$literalExpectation("WINDOW", true);
  var peg$e78 = peg$literalExpectation("WITH", true);
  var peg$e79 = peg$literalExpectation("(", true);
  var peg$e80 = peg$literalExpectation(")", true);
  var peg$e81 = peg$literalExpectation("()", true);
  var peg$e82 = peg$literalExpectation("=", true);
  var peg$e83 = peg$literalExpectation(",", true);
  var peg$e84 = peg$literalExpectation(".", true);

// @ts-ignore
  var peg$currPos = 0;
// @ts-ignore
  var peg$savedPos = 0;
// @ts-ignore
  var peg$posDetailsCache = [{ line: 1, column: 1 }];
// @ts-ignore
  var peg$maxFailPos = 0;
// @ts-ignore
  var peg$maxFailExpected = [];
// @ts-ignore
  var peg$silentFails = 0;

// @ts-ignore
  var peg$resultsCache = {};

// @ts-ignore
  var peg$tracer = "tracer" in options ? options.tracer : new peg$DefaultTracer();

// @ts-ignore
  var peg$result;

// @ts-ignore
  if ("startRule" in options) {
// @ts-ignore
    if (!(options.startRule in peg$startRuleFunctions)) {
// @ts-ignore
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

// @ts-ignore
    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

// @ts-ignore
  function text() {
// @ts-ignore
    return input.substring(peg$savedPos, peg$currPos);
  }

// @ts-ignore
  function offset() {
// @ts-ignore
    return peg$savedPos;
  }

// @ts-ignore
  function range() {
// @ts-ignore
    return {
// @ts-ignore
      source: peg$source,
// @ts-ignore
      start: peg$savedPos,
// @ts-ignore
      end: peg$currPos
    };
  }

// @ts-ignore
  function location() {
// @ts-ignore
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

// @ts-ignore
  function expected(description, location) {
// @ts-ignore
    location = location !== undefined
// @ts-ignore
      ? location
// @ts-ignore
      : peg$computeLocation(peg$savedPos, peg$currPos);

// @ts-ignore
    throw peg$buildStructuredError(
// @ts-ignore
      [peg$otherExpectation(description)],
// @ts-ignore
      input.substring(peg$savedPos, peg$currPos),
// @ts-ignore
      location
    );
  }

// @ts-ignore
  function error(message, location) {
// @ts-ignore
    location = location !== undefined
// @ts-ignore
      ? location
// @ts-ignore
      : peg$computeLocation(peg$savedPos, peg$currPos);

// @ts-ignore
    throw peg$buildSimpleError(message, location);
  }

// @ts-ignore
  function peg$literalExpectation(text, ignoreCase) {
// @ts-ignore
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

// @ts-ignore
  function peg$classExpectation(parts, inverted, ignoreCase) {
// @ts-ignore
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

// @ts-ignore
  function peg$anyExpectation() {
// @ts-ignore
    return { type: "any" };
  }

// @ts-ignore
  function peg$endExpectation() {
// @ts-ignore
    return { type: "end" };
  }

// @ts-ignore
  function peg$otherExpectation(description) {
// @ts-ignore
    return { type: "other", description: description };
  }

// @ts-ignore
  function peg$computePosDetails(pos) {
// @ts-ignore
    var details = peg$posDetailsCache[pos];
// @ts-ignore
    var p;

// @ts-ignore
    if (details) {
// @ts-ignore
      return details;
// @ts-ignore
    } else {
// @ts-ignore
      p = pos - 1;
// @ts-ignore
      while (!peg$posDetailsCache[p]) {
// @ts-ignore
        p--;
      }

// @ts-ignore
      details = peg$posDetailsCache[p];
// @ts-ignore
      details = {
// @ts-ignore
        line: details.line,
// @ts-ignore
        column: details.column
      };

// @ts-ignore
      while (p < pos) {
// @ts-ignore
        if (input.charCodeAt(p) === 10) {
// @ts-ignore
          details.line++;
// @ts-ignore
          details.column = 1;
// @ts-ignore
        } else {
// @ts-ignore
          details.column++;
        }

// @ts-ignore
        p++;
      }

// @ts-ignore
      peg$posDetailsCache[pos] = details;

// @ts-ignore
      return details;
    }
  }

// @ts-ignore
  function peg$computeLocation(startPos, endPos, offset) {
// @ts-ignore
    var startPosDetails = peg$computePosDetails(startPos);
// @ts-ignore
    var endPosDetails = peg$computePosDetails(endPos);

// @ts-ignore
    var res = {
// @ts-ignore
      source: peg$source,
// @ts-ignore
      start: {
// @ts-ignore
        offset: startPos,
// @ts-ignore
        line: startPosDetails.line,
// @ts-ignore
        column: startPosDetails.column
      },
// @ts-ignore
      end: {
// @ts-ignore
        offset: endPos,
// @ts-ignore
        line: endPosDetails.line,
// @ts-ignore
        column: endPosDetails.column
      }
    };
// @ts-ignore
    if (offset && peg$source && (typeof peg$source.offset === "function")) {
// @ts-ignore
      res.start = peg$source.offset(res.start);
// @ts-ignore
      res.end = peg$source.offset(res.end);
    }
// @ts-ignore
    return res;
  }

// @ts-ignore
  function peg$fail(expected) {
// @ts-ignore
    if (peg$currPos < peg$maxFailPos) { return; }

// @ts-ignore
    if (peg$currPos > peg$maxFailPos) {
// @ts-ignore
      peg$maxFailPos = peg$currPos;
// @ts-ignore
      peg$maxFailExpected = [];
    }

// @ts-ignore
    peg$maxFailExpected.push(expected);
  }

// @ts-ignore
  function peg$buildSimpleError(message, location) {
// @ts-ignore
    return new peg$SyntaxError(message, null, null, location);
  }

// @ts-ignore
  function peg$buildStructuredError(expected, found, location) {
// @ts-ignore
    return new peg$SyntaxError(
// @ts-ignore
      peg$SyntaxError.buildMessage(expected, found),
// @ts-ignore
      expected,
// @ts-ignore
      found,
// @ts-ignore
      location
    );
  }

// @ts-ignore
  function // @ts-ignore
peg$parsequery_statement() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "query_statement",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 0;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "query_statement",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "query_statement",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$parsequery_expr();

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "query_statement",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "query_statement",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsequery_expr() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "query_expr",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 1;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "query_expr",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "query_expr",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$currPos;
// @ts-ignore
    s2 = peg$parseK_WITH();
// @ts-ignore
    if (s2 !== peg$FAILED) {
// @ts-ignore
      s3 = peg$parse_();
// @ts-ignore
      s4 = peg$parseK_RECURSIVE();
// @ts-ignore
      if (s4 === peg$FAILED) {
// @ts-ignore
        s4 = null;
      }
// @ts-ignore
      s5 = peg$parse_();
// @ts-ignore
      s6 = [];
// @ts-ignore
      s7 = peg$parsenon_recursive_cte();
// @ts-ignore
      if (s7 === peg$FAILED) {
// @ts-ignore
        s7 = peg$parserecursive_cte();
      }
// @ts-ignore
      while (s7 !== peg$FAILED) {
// @ts-ignore
        s6.push(s7);
// @ts-ignore
        s7 = peg$currPos;
// @ts-ignore
        s8 = peg$currPos;
// @ts-ignore
        s9 = peg$parse_();
// @ts-ignore
        s10 = peg$parseCOMMA();
// @ts-ignore
        if (s10 !== peg$FAILED) {
// @ts-ignore
          s11 = peg$parse_();
// @ts-ignore
          s9 = [s9, s10, s11];
// @ts-ignore
          s8 = s9;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s8;
// @ts-ignore
          s8 = peg$FAILED;
        }
// @ts-ignore
        if (s8 !== peg$FAILED) {
// @ts-ignore
          s8 = peg$parsenon_recursive_cte();
// @ts-ignore
          if (s8 === peg$FAILED) {
// @ts-ignore
            s8 = peg$parserecursive_cte();
          }
// @ts-ignore
          if (s8 === peg$FAILED) {
// @ts-ignore
            peg$currPos = s7;
// @ts-ignore
            s7 = peg$FAILED;
// @ts-ignore
          } else {
// @ts-ignore
            s7 = s8;
          }
// @ts-ignore
        } else {
// @ts-ignore
          s7 = s8;
        }
      }
// @ts-ignore
      s2 = [s2, s3, s4, s5, s6];
// @ts-ignore
      s1 = s2;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s1;
// @ts-ignore
      s1 = peg$FAILED;
    }
// @ts-ignore
    if (s1 === peg$FAILED) {
// @ts-ignore
      s1 = null;
    }
// @ts-ignore
    s2 = peg$parse_();
// @ts-ignore
    s3 = peg$currPos;
// @ts-ignore
    s4 = [];
// @ts-ignore
    s5 = peg$parsequery_expr_02();
// @ts-ignore
    while (s5 !== peg$FAILED) {
// @ts-ignore
      s4.push(s5);
// @ts-ignore
      s5 = peg$currPos;
// @ts-ignore
      s6 = peg$currPos;
// @ts-ignore
      s7 = peg$parse_();
// @ts-ignore
      s8 = peg$parseset_operator();
// @ts-ignore
      if (s8 !== peg$FAILED) {
// @ts-ignore
        s9 = peg$parse_();
// @ts-ignore
        s10 = peg$parsequery_expr_02();
// @ts-ignore
        if (s10 !== peg$FAILED) {
// @ts-ignore
          s7 = [s7, s8, s9, s10];
// @ts-ignore
          s6 = s7;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s6;
// @ts-ignore
          s6 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s6;
// @ts-ignore
        s6 = peg$FAILED;
      }
// @ts-ignore
      if (s6 !== peg$FAILED) {
// @ts-ignore
        s6 = peg$parsequery_expr_02();
// @ts-ignore
        if (s6 === peg$FAILED) {
// @ts-ignore
          peg$currPos = s5;
// @ts-ignore
          s5 = peg$FAILED;
// @ts-ignore
        } else {
// @ts-ignore
          s5 = s6;
        }
// @ts-ignore
      } else {
// @ts-ignore
        s5 = s6;
      }
    }
// @ts-ignore
    if (s4.length < 1) {
// @ts-ignore
      peg$currPos = s3;
// @ts-ignore
      s3 = peg$FAILED;
// @ts-ignore
    } else {
// @ts-ignore
      s3 = s4;
    }
// @ts-ignore
    if (s3 !== peg$FAILED) {
// @ts-ignore
      s1 = [s1, s2, s3];
// @ts-ignore
      s0 = s1;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "query_expr",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "query_expr",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsequery_expr_02() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "query_expr_02",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 2;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "query_expr_02",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "query_expr_02",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$currPos;
// @ts-ignore
    s2 = peg$parseLPAREN();
// @ts-ignore
    if (s2 !== peg$FAILED) {
// @ts-ignore
      s3 = peg$parse_();
// @ts-ignore
      s4 = peg$parsequery_expr();
// @ts-ignore
      if (s4 !== peg$FAILED) {
// @ts-ignore
        s5 = peg$parse_();
// @ts-ignore
        s6 = peg$parseRPAREN();
// @ts-ignore
        if (s6 !== peg$FAILED) {
// @ts-ignore
          s2 = [s2, s3, s4, s5, s6];
// @ts-ignore
          s1 = s2;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s1;
// @ts-ignore
          s1 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s1;
// @ts-ignore
        s1 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s1;
// @ts-ignore
      s1 = peg$FAILED;
    }
// @ts-ignore
    if (s1 === peg$FAILED) {
// @ts-ignore
      s1 = peg$parseselect();
    }
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = [];
// @ts-ignore
      s4 = peg$currPos;
// @ts-ignore
      s5 = peg$parseK_ORDER();
// @ts-ignore
      if (s5 !== peg$FAILED) {
// @ts-ignore
        s6 = peg$parse_();
// @ts-ignore
        s7 = peg$parseK_BY();
// @ts-ignore
        if (s7 !== peg$FAILED) {
// @ts-ignore
          s8 = peg$parse_();
// @ts-ignore
          s9 = peg$parseexpression();
// @ts-ignore
          if (s9 !== peg$FAILED) {
// @ts-ignore
            s10 = peg$parse_();
// @ts-ignore
            s11 = peg$parseK_ASC();
// @ts-ignore
            if (s11 === peg$FAILED) {
// @ts-ignore
              s11 = peg$parseK_DESC();
            }
// @ts-ignore
            if (s11 === peg$FAILED) {
// @ts-ignore
              s11 = null;
            }
// @ts-ignore
            s5 = [s5, s6, s7, s8, s9, s10, s11];
// @ts-ignore
            s4 = s5;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s4;
// @ts-ignore
            s4 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s4;
// @ts-ignore
          s4 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s4;
// @ts-ignore
        s4 = peg$FAILED;
      }
// @ts-ignore
      while (s4 !== peg$FAILED) {
// @ts-ignore
        s3.push(s4);
// @ts-ignore
        s4 = peg$currPos;
// @ts-ignore
        s5 = peg$parseK_ORDER();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s6 = peg$parse_();
// @ts-ignore
          s7 = peg$parseK_BY();
// @ts-ignore
          if (s7 !== peg$FAILED) {
// @ts-ignore
            s8 = peg$parse_();
// @ts-ignore
            s9 = peg$parseexpression();
// @ts-ignore
            if (s9 !== peg$FAILED) {
// @ts-ignore
              s10 = peg$parse_();
// @ts-ignore
              s11 = peg$parseK_ASC();
// @ts-ignore
              if (s11 === peg$FAILED) {
// @ts-ignore
                s11 = peg$parseK_DESC();
              }
// @ts-ignore
              if (s11 === peg$FAILED) {
// @ts-ignore
                s11 = null;
              }
// @ts-ignore
              s5 = [s5, s6, s7, s8, s9, s10, s11];
// @ts-ignore
              s4 = s5;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s4;
// @ts-ignore
              s4 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s4;
// @ts-ignore
            s4 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s4;
// @ts-ignore
          s4 = peg$FAILED;
        }
      }
// @ts-ignore
      s4 = peg$parse_();
// @ts-ignore
      s5 = peg$currPos;
// @ts-ignore
      s6 = peg$parseK_LIMIT();
// @ts-ignore
      if (s6 !== peg$FAILED) {
// @ts-ignore
        s7 = peg$parse_();
// @ts-ignore
        s8 = peg$parseexpression();
// @ts-ignore
        if (s8 !== peg$FAILED) {
// @ts-ignore
          s9 = peg$parse_();
// @ts-ignore
          s10 = peg$currPos;
// @ts-ignore
          s11 = peg$parseK_OFFSET();
// @ts-ignore
          if (s11 !== peg$FAILED) {
// @ts-ignore
            s12 = peg$parse_();
// @ts-ignore
            s13 = peg$parseexpression();
// @ts-ignore
            if (s13 !== peg$FAILED) {
// @ts-ignore
              s11 = [s11, s12, s13];
// @ts-ignore
              s10 = s11;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s10;
// @ts-ignore
              s10 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s10;
// @ts-ignore
            s10 = peg$FAILED;
          }
// @ts-ignore
          if (s10 === peg$FAILED) {
// @ts-ignore
            s10 = null;
          }
// @ts-ignore
          s6 = [s6, s7, s8, s9, s10];
// @ts-ignore
          s5 = s6;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s5;
// @ts-ignore
          s5 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s5;
// @ts-ignore
        s5 = peg$FAILED;
      }
// @ts-ignore
      if (s5 === peg$FAILED) {
// @ts-ignore
        s5 = null;
      }
// @ts-ignore
      s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
      s0 = s1;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "query_expr_02",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "query_expr_02",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseselect() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21, s22, s23, s24;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "select",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 3;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "select",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "select",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_SELECT();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$currPos;
// @ts-ignore
      s4 = peg$parseK_WITH();
// @ts-ignore
      if (s4 !== peg$FAILED) {
// @ts-ignore
        s5 = peg$parse_();
// @ts-ignore
        s6 = peg$parsedifferential_privacy_clause();
// @ts-ignore
        if (s6 !== peg$FAILED) {
// @ts-ignore
          s4 = [s4, s5, s6];
// @ts-ignore
          s3 = s4;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s3;
// @ts-ignore
          s3 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s3;
// @ts-ignore
        s3 = peg$FAILED;
      }
// @ts-ignore
      if (s3 === peg$FAILED) {
// @ts-ignore
        s3 = null;
      }
// @ts-ignore
      s4 = peg$parse_();
// @ts-ignore
      s5 = peg$parseK_ALL();
// @ts-ignore
      if (s5 === peg$FAILED) {
// @ts-ignore
        s5 = peg$parseK_DISTINCT();
      }
// @ts-ignore
      if (s5 === peg$FAILED) {
// @ts-ignore
        s5 = null;
      }
// @ts-ignore
      s6 = peg$parse_();
// @ts-ignore
      s7 = peg$currPos;
// @ts-ignore
      s8 = peg$parseK_AS();
// @ts-ignore
      if (s8 !== peg$FAILED) {
// @ts-ignore
        s9 = peg$parse_();
// @ts-ignore
        s10 = peg$parseK_STRUCT();
// @ts-ignore
        if (s10 === peg$FAILED) {
// @ts-ignore
          s10 = peg$parseK_VALUE();
        }
// @ts-ignore
        if (s10 !== peg$FAILED) {
// @ts-ignore
          s8 = [s8, s9, s10];
// @ts-ignore
          s7 = s8;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s7;
// @ts-ignore
          s7 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s7;
// @ts-ignore
        s7 = peg$FAILED;
      }
// @ts-ignore
      if (s7 === peg$FAILED) {
// @ts-ignore
        s7 = null;
      }
// @ts-ignore
      s8 = peg$parse_();
// @ts-ignore
      s9 = peg$parseselect_list();
// @ts-ignore
      if (s9 !== peg$FAILED) {
// @ts-ignore
        s10 = peg$parse_();
// @ts-ignore
        s11 = peg$currPos;
// @ts-ignore
        s12 = peg$parseK_FROM();
// @ts-ignore
        if (s12 !== peg$FAILED) {
// @ts-ignore
          s13 = peg$parse_();
// @ts-ignore
          s14 = peg$currPos;
// @ts-ignore
          s15 = [];
// @ts-ignore
          s16 = peg$parsefrom_clause();
// @ts-ignore
          while (s16 !== peg$FAILED) {
// @ts-ignore
            s15.push(s16);
// @ts-ignore
            s16 = peg$currPos;
// @ts-ignore
            s17 = peg$currPos;
// @ts-ignore
            s18 = peg$parse_();
// @ts-ignore
            s19 = peg$parseCOMMA();
// @ts-ignore
            if (s19 !== peg$FAILED) {
// @ts-ignore
              s20 = peg$parse_();
// @ts-ignore
              s18 = [s18, s19, s20];
// @ts-ignore
              s17 = s18;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s17;
// @ts-ignore
              s17 = peg$FAILED;
            }
// @ts-ignore
            if (s17 !== peg$FAILED) {
// @ts-ignore
              s17 = peg$parsefrom_clause();
// @ts-ignore
              if (s17 === peg$FAILED) {
// @ts-ignore
                peg$currPos = s16;
// @ts-ignore
                s16 = peg$FAILED;
// @ts-ignore
              } else {
// @ts-ignore
                s16 = s17;
              }
// @ts-ignore
            } else {
// @ts-ignore
              s16 = s17;
            }
          }
// @ts-ignore
          if (s15.length < 1) {
// @ts-ignore
            peg$currPos = s14;
// @ts-ignore
            s14 = peg$FAILED;
// @ts-ignore
          } else {
// @ts-ignore
            s14 = s15;
          }
// @ts-ignore
          if (s14 !== peg$FAILED) {
// @ts-ignore
            s12 = [s12, s13, s14];
// @ts-ignore
            s11 = s12;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s11;
// @ts-ignore
            s11 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s11;
// @ts-ignore
          s11 = peg$FAILED;
        }
// @ts-ignore
        if (s11 === peg$FAILED) {
// @ts-ignore
          s11 = null;
        }
// @ts-ignore
        s12 = peg$parse_();
// @ts-ignore
        s13 = peg$currPos;
// @ts-ignore
        s14 = peg$parseK_WHERE();
// @ts-ignore
        if (s14 !== peg$FAILED) {
// @ts-ignore
          s15 = peg$parse_();
// @ts-ignore
          s16 = peg$parsebool_expression();
// @ts-ignore
          if (s16 !== peg$FAILED) {
// @ts-ignore
            s14 = [s14, s15, s16];
// @ts-ignore
            s13 = s14;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s13;
// @ts-ignore
            s13 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s13;
// @ts-ignore
          s13 = peg$FAILED;
        }
// @ts-ignore
        if (s13 === peg$FAILED) {
// @ts-ignore
          s13 = null;
        }
// @ts-ignore
        s14 = peg$parse_();
// @ts-ignore
        s15 = peg$currPos;
// @ts-ignore
        s16 = peg$parseK_GROUP();
// @ts-ignore
        if (s16 !== peg$FAILED) {
// @ts-ignore
          s17 = peg$parse_();
// @ts-ignore
          s18 = peg$parseK_BY();
// @ts-ignore
          if (s18 !== peg$FAILED) {
// @ts-ignore
            s19 = peg$parse_();
// @ts-ignore
            s20 = peg$parsegroup_by_specification();
// @ts-ignore
            if (s20 !== peg$FAILED) {
// @ts-ignore
              s16 = [s16, s17, s18, s19, s20];
// @ts-ignore
              s15 = s16;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s15;
// @ts-ignore
              s15 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s15;
// @ts-ignore
            s15 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s15;
// @ts-ignore
          s15 = peg$FAILED;
        }
// @ts-ignore
        if (s15 === peg$FAILED) {
// @ts-ignore
          s15 = null;
        }
// @ts-ignore
        s16 = peg$parse_();
// @ts-ignore
        s17 = peg$currPos;
// @ts-ignore
        s18 = peg$parseK_HAVING();
// @ts-ignore
        if (s18 !== peg$FAILED) {
// @ts-ignore
          s19 = peg$parse_();
// @ts-ignore
          s20 = peg$parsebool_expression();
// @ts-ignore
          if (s20 !== peg$FAILED) {
// @ts-ignore
            s18 = [s18, s19, s20];
// @ts-ignore
            s17 = s18;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s17;
// @ts-ignore
            s17 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s17;
// @ts-ignore
          s17 = peg$FAILED;
        }
// @ts-ignore
        if (s17 === peg$FAILED) {
// @ts-ignore
          s17 = null;
        }
// @ts-ignore
        s18 = peg$parse_();
// @ts-ignore
        s19 = peg$currPos;
// @ts-ignore
        s20 = peg$parseK_QUALIFY();
// @ts-ignore
        if (s20 !== peg$FAILED) {
// @ts-ignore
          s21 = peg$parse_();
// @ts-ignore
          s22 = peg$parsebool_expression();
// @ts-ignore
          if (s22 !== peg$FAILED) {
// @ts-ignore
            s20 = [s20, s21, s22];
// @ts-ignore
            s19 = s20;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s19;
// @ts-ignore
            s19 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s19;
// @ts-ignore
          s19 = peg$FAILED;
        }
// @ts-ignore
        if (s19 === peg$FAILED) {
// @ts-ignore
          s19 = null;
        }
// @ts-ignore
        s20 = peg$parse_();
// @ts-ignore
        s21 = peg$currPos;
// @ts-ignore
        s22 = peg$parseK_WINDOW();
// @ts-ignore
        if (s22 !== peg$FAILED) {
// @ts-ignore
          s23 = peg$parse_();
// @ts-ignore
          s24 = peg$parsewindow_clause();
// @ts-ignore
          s22 = [s22, s23, s24];
// @ts-ignore
          s21 = s22;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s21;
// @ts-ignore
          s21 = peg$FAILED;
        }
// @ts-ignore
        if (s21 === peg$FAILED) {
// @ts-ignore
          s21 = null;
        }
// @ts-ignore
        s1 = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21];
// @ts-ignore
        s0 = s1;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "select",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "select",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseselect_list() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "select_list",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 4;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "select_list",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "select_list",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = [];
// @ts-ignore
    s2 = peg$parseselect_all();
// @ts-ignore
    if (s2 === peg$FAILED) {
// @ts-ignore
      s2 = peg$parseselect_expression();
    }
// @ts-ignore
    while (s2 !== peg$FAILED) {
// @ts-ignore
      s1.push(s2);
// @ts-ignore
      s2 = peg$currPos;
// @ts-ignore
      s3 = peg$currPos;
// @ts-ignore
      s4 = peg$parse_();
// @ts-ignore
      s5 = peg$parseCOMMA();
// @ts-ignore
      if (s5 !== peg$FAILED) {
// @ts-ignore
        s6 = peg$parse_();
// @ts-ignore
        s4 = [s4, s5, s6];
// @ts-ignore
        s3 = s4;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s3;
// @ts-ignore
        s3 = peg$FAILED;
      }
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s3 = peg$parseselect_all();
// @ts-ignore
        if (s3 === peg$FAILED) {
// @ts-ignore
          s3 = peg$parseselect_expression();
        }
// @ts-ignore
        if (s3 === peg$FAILED) {
// @ts-ignore
          peg$currPos = s2;
// @ts-ignore
          s2 = peg$FAILED;
// @ts-ignore
        } else {
// @ts-ignore
          s2 = s3;
        }
// @ts-ignore
      } else {
// @ts-ignore
        s2 = s3;
      }
    }
// @ts-ignore
    if (s1.length < 1) {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = s1;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "select_list",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "select_list",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseselect_all() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "select_all",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 5;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "select_all",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "select_all",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$currPos;
// @ts-ignore
    s2 = peg$parseexpression();
// @ts-ignore
    if (s2 !== peg$FAILED) {
// @ts-ignore
      s3 = peg$parse_();
// @ts-ignore
      s4 = peg$parseDOT();
// @ts-ignore
      if (s4 !== peg$FAILED) {
// @ts-ignore
        s2 = [s2, s3, s4];
// @ts-ignore
        s1 = s2;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s1;
// @ts-ignore
        s1 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s1;
// @ts-ignore
      s1 = peg$FAILED;
    }
// @ts-ignore
    if (s1 === peg$FAILED) {
// @ts-ignore
      s1 = null;
    }
// @ts-ignore
    s2 = peg$parse_();
// @ts-ignore
    if (input.charCodeAt(peg$currPos) === 42) {
// @ts-ignore
      s3 = peg$c0;
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s3 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e0); }
    }
// @ts-ignore
    if (s3 !== peg$FAILED) {
// @ts-ignore
      s4 = peg$parse_();
// @ts-ignore
      s5 = peg$currPos;
// @ts-ignore
      s6 = peg$parseK_EXCEPT();
// @ts-ignore
      if (s6 !== peg$FAILED) {
// @ts-ignore
        s7 = peg$parse_();
// @ts-ignore
        s8 = peg$parseLPAREN();
// @ts-ignore
        if (s8 !== peg$FAILED) {
// @ts-ignore
          s9 = peg$parse_();
// @ts-ignore
          s10 = [];
// @ts-ignore
          s11 = peg$parsecolumn_name();
// @ts-ignore
          while (s11 !== peg$FAILED) {
// @ts-ignore
            s10.push(s11);
// @ts-ignore
            s11 = peg$currPos;
// @ts-ignore
            s12 = peg$currPos;
// @ts-ignore
            s13 = peg$parse_();
// @ts-ignore
            s14 = peg$parseCOMMA();
// @ts-ignore
            if (s14 !== peg$FAILED) {
// @ts-ignore
              s15 = peg$parse_();
// @ts-ignore
              s13 = [s13, s14, s15];
// @ts-ignore
              s12 = s13;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s12;
// @ts-ignore
              s12 = peg$FAILED;
            }
// @ts-ignore
            if (s12 !== peg$FAILED) {
// @ts-ignore
              s12 = peg$parsecolumn_name();
// @ts-ignore
              if (s12 === peg$FAILED) {
// @ts-ignore
                peg$currPos = s11;
// @ts-ignore
                s11 = peg$FAILED;
// @ts-ignore
              } else {
// @ts-ignore
                s11 = s12;
              }
// @ts-ignore
            } else {
// @ts-ignore
              s11 = s12;
            }
          }
// @ts-ignore
          s11 = peg$parseRPAREN();
// @ts-ignore
          if (s11 !== peg$FAILED) {
// @ts-ignore
            s6 = [s6, s7, s8, s9, s10, s11];
// @ts-ignore
            s5 = s6;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s5;
// @ts-ignore
            s5 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s5;
// @ts-ignore
          s5 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s5;
// @ts-ignore
        s5 = peg$FAILED;
      }
// @ts-ignore
      if (s5 === peg$FAILED) {
// @ts-ignore
        s5 = null;
      }
// @ts-ignore
      s6 = peg$parse_();
// @ts-ignore
      s7 = peg$currPos;
// @ts-ignore
      s8 = peg$parseK_REPLACE();
// @ts-ignore
      if (s8 !== peg$FAILED) {
// @ts-ignore
        s9 = peg$parse_();
// @ts-ignore
        s10 = peg$parseLPAREN();
// @ts-ignore
        if (s10 !== peg$FAILED) {
// @ts-ignore
          s11 = peg$parse_();
// @ts-ignore
          s12 = [];
// @ts-ignore
          s13 = peg$currPos;
// @ts-ignore
          s14 = peg$parseexpression();
// @ts-ignore
          if (s14 !== peg$FAILED) {
// @ts-ignore
            s15 = peg$parse_();
// @ts-ignore
            s16 = peg$parseK_AS();
// @ts-ignore
            if (s16 === peg$FAILED) {
// @ts-ignore
              s16 = null;
            }
// @ts-ignore
            s17 = peg$parse_();
// @ts-ignore
            s18 = peg$parsecolumn_name();
// @ts-ignore
            if (s18 !== peg$FAILED) {
// @ts-ignore
              s14 = [s14, s15, s16, s17, s18];
// @ts-ignore
              s13 = s14;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s13;
// @ts-ignore
              s13 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s13;
// @ts-ignore
            s13 = peg$FAILED;
          }
// @ts-ignore
          while (s13 !== peg$FAILED) {
// @ts-ignore
            s12.push(s13);
// @ts-ignore
            s13 = peg$currPos;
// @ts-ignore
            s14 = peg$currPos;
// @ts-ignore
            s15 = peg$parse_();
// @ts-ignore
            s16 = peg$parseCOMMA();
// @ts-ignore
            if (s16 !== peg$FAILED) {
// @ts-ignore
              s17 = peg$parse_();
// @ts-ignore
              s15 = [s15, s16, s17];
// @ts-ignore
              s14 = s15;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s14;
// @ts-ignore
              s14 = peg$FAILED;
            }
// @ts-ignore
            if (s14 !== peg$FAILED) {
// @ts-ignore
              s14 = peg$currPos;
// @ts-ignore
              s15 = peg$parseexpression();
// @ts-ignore
              if (s15 !== peg$FAILED) {
// @ts-ignore
                s16 = peg$parse_();
// @ts-ignore
                s17 = peg$parseK_AS();
// @ts-ignore
                if (s17 === peg$FAILED) {
// @ts-ignore
                  s17 = null;
                }
// @ts-ignore
                s18 = peg$parse_();
// @ts-ignore
                s19 = peg$parsecolumn_name();
// @ts-ignore
                if (s19 !== peg$FAILED) {
// @ts-ignore
                  s15 = [s15, s16, s17, s18, s19];
// @ts-ignore
                  s14 = s15;
// @ts-ignore
                } else {
// @ts-ignore
                  peg$currPos = s14;
// @ts-ignore
                  s14 = peg$FAILED;
                }
// @ts-ignore
              } else {
// @ts-ignore
                peg$currPos = s14;
// @ts-ignore
                s14 = peg$FAILED;
              }
// @ts-ignore
              if (s14 === peg$FAILED) {
// @ts-ignore
                peg$currPos = s13;
// @ts-ignore
                s13 = peg$FAILED;
// @ts-ignore
              } else {
// @ts-ignore
                s13 = s14;
              }
// @ts-ignore
            } else {
// @ts-ignore
              s13 = s14;
            }
          }
// @ts-ignore
          s13 = peg$parse_();
// @ts-ignore
          s14 = peg$parseRPAREN();
// @ts-ignore
          if (s14 !== peg$FAILED) {
// @ts-ignore
            s8 = [s8, s9, s10, s11, s12, s13, s14];
// @ts-ignore
            s7 = s8;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s7;
// @ts-ignore
            s7 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s7;
// @ts-ignore
          s7 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s7;
// @ts-ignore
        s7 = peg$FAILED;
      }
// @ts-ignore
      if (s7 === peg$FAILED) {
// @ts-ignore
        s7 = null;
      }
// @ts-ignore
      s1 = [s1, s2, s3, s4, s5, s6, s7];
// @ts-ignore
      s0 = s1;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "select_all",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "select_all",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseselect_expression() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "select_expression",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 6;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "select_expression",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "select_expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseexpression();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$currPos;
// @ts-ignore
      s4 = peg$parseK_AS();
// @ts-ignore
      if (s4 === peg$FAILED) {
// @ts-ignore
        s4 = null;
      }
// @ts-ignore
      s5 = peg$parse_();
// @ts-ignore
      s6 = peg$parsealias();
// @ts-ignore
      if (s6 !== peg$FAILED) {
// @ts-ignore
        s4 = [s4, s5, s6];
// @ts-ignore
        s3 = s4;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s3;
// @ts-ignore
        s3 = peg$FAILED;
      }
// @ts-ignore
      if (s3 === peg$FAILED) {
// @ts-ignore
        s3 = null;
      }
// @ts-ignore
      s1 = [s1, s2, s3];
// @ts-ignore
      s0 = s1;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "select_expression",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "select_expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsefrom_clause() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "from_clause",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 7;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "from_clause",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "from_clause",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parsefrom_item();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parsepivot_operator();
// @ts-ignore
      if (s3 === peg$FAILED) {
// @ts-ignore
        s3 = peg$parseunpivot_operator();
      }
// @ts-ignore
      if (s3 === peg$FAILED) {
// @ts-ignore
        s3 = null;
      }
// @ts-ignore
      s4 = peg$parse_();
// @ts-ignore
      s5 = peg$parsetablesample_operator();
// @ts-ignore
      if (s5 === peg$FAILED) {
// @ts-ignore
        s5 = null;
      }
// @ts-ignore
      s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
      s0 = s1;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "from_clause",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "from_clause",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsefrom_item() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "from_item",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 8;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "from_item",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "from_item",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$parsefrom_item_without_join();
// @ts-ignore
    if (s0 === peg$FAILED) {
// @ts-ignore
      s0 = peg$parsefrom_item_with_join();
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "from_item",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "from_item",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsefrom_item_with_join() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "from_item_with_join",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 9;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "from_item_with_join",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "from_item_with_join",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parsefrom_item_with_join_with_paren();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parsecross_join_operator();
// @ts-ignore
      if (s3 === peg$FAILED) {
// @ts-ignore
        s3 = peg$parsecondition_join_operator();
      }
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parsefrom_item_with_join_with_paren();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
          s0 = s1;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "from_item_with_join",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "from_item_with_join",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsefrom_item_with_join_with_paren() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "from_item_with_join_with_paren",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 10;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "from_item_with_join_with_paren",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "from_item_with_join_with_paren",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseLPAREN();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parsefrom_item();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parseRPAREN();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
          s0 = s1;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }
// @ts-ignore
    if (s0 === peg$FAILED) {
// @ts-ignore
      s0 = peg$parsefrom_item_without_join();
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "from_item_with_join_with_paren",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "from_item_with_join_with_paren",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsefrom_item_without_join() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "from_item_without_join",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 11;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "from_item_without_join",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "from_item_without_join",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parsetable_name();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseas_alias();
// @ts-ignore
      if (s3 === peg$FAILED) {
// @ts-ignore
        s3 = null;
      }
// @ts-ignore
      s4 = peg$parse_();
// @ts-ignore
      s5 = peg$currPos;
// @ts-ignore
      s6 = peg$parseK_FOR();
// @ts-ignore
      if (s6 !== peg$FAILED) {
// @ts-ignore
        s7 = peg$parse_();
// @ts-ignore
        s8 = peg$parseK_SYSTEM_TIME();
// @ts-ignore
        if (s8 !== peg$FAILED) {
// @ts-ignore
          s9 = peg$parse_();
// @ts-ignore
          s10 = peg$parseK_AS();
// @ts-ignore
          if (s10 !== peg$FAILED) {
// @ts-ignore
            s11 = peg$parse_();
// @ts-ignore
            s12 = peg$parseK_OF();
// @ts-ignore
            if (s12 !== peg$FAILED) {
// @ts-ignore
              s13 = peg$parse_();
// @ts-ignore
              s14 = peg$parsetimestamp_expression();
// @ts-ignore
              if (s14 !== peg$FAILED) {
// @ts-ignore
                s6 = [s6, s7, s8, s9, s10, s11, s12, s13, s14];
// @ts-ignore
                s5 = s6;
// @ts-ignore
              } else {
// @ts-ignore
                peg$currPos = s5;
// @ts-ignore
                s5 = peg$FAILED;
              }
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s5;
// @ts-ignore
              s5 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s5;
// @ts-ignore
            s5 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s5;
// @ts-ignore
          s5 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s5;
// @ts-ignore
        s5 = peg$FAILED;
      }
// @ts-ignore
      if (s5 === peg$FAILED) {
// @ts-ignore
        s5 = null;
      }
// @ts-ignore
      s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
      s0 = s1;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }
// @ts-ignore
    if (s0 === peg$FAILED) {
// @ts-ignore
      s0 = peg$currPos;
// @ts-ignore
      s1 = peg$parseLPAREN();
// @ts-ignore
      if (s1 !== peg$FAILED) {
// @ts-ignore
        s2 = peg$parse_();
// @ts-ignore
        s3 = peg$parsequery_expr();
// @ts-ignore
        if (s3 !== peg$FAILED) {
// @ts-ignore
          s4 = peg$parse_();
// @ts-ignore
          s5 = peg$parseRPAREN();
// @ts-ignore
          if (s5 !== peg$FAILED) {
// @ts-ignore
            s6 = peg$parse_();
// @ts-ignore
            s7 = peg$parseas_alias();
// @ts-ignore
            if (s7 === peg$FAILED) {
// @ts-ignore
              s7 = null;
            }
// @ts-ignore
            s1 = [s1, s2, s3, s4, s5, s6, s7];
// @ts-ignore
            s0 = s1;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
      if (s0 === peg$FAILED) {
// @ts-ignore
        s0 = peg$parsefield_path();
// @ts-ignore
        if (s0 === peg$FAILED) {
// @ts-ignore
          s0 = peg$parseunnest_operator();
// @ts-ignore
          if (s0 === peg$FAILED) {
// @ts-ignore
            s0 = peg$currPos;
// @ts-ignore
            s1 = peg$parsecte_name();
// @ts-ignore
            if (s1 !== peg$FAILED) {
// @ts-ignore
              s2 = peg$parse_();
// @ts-ignore
              s3 = peg$parseas_alias();
// @ts-ignore
              if (s3 === peg$FAILED) {
// @ts-ignore
                s3 = null;
              }
// @ts-ignore
              s1 = [s1, s2, s3];
// @ts-ignore
              s0 = s1;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s0;
// @ts-ignore
              s0 = peg$FAILED;
            }
          }
        }
      }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "from_item_without_join",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "from_item_without_join",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsefield_path() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "field_path",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 12;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "field_path",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "field_path",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = [];
// @ts-ignore
    if (peg$r0.test(input.charAt(peg$currPos))) {
// @ts-ignore
      s1 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s1 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e1); }
    }
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      while (s1 !== peg$FAILED) {
// @ts-ignore
        s0.push(s1);
// @ts-ignore
        if (peg$r0.test(input.charAt(peg$currPos))) {
// @ts-ignore
          s1 = input.charAt(peg$currPos);
// @ts-ignore
          peg$currPos++;
// @ts-ignore
        } else {
// @ts-ignore
          s1 = peg$FAILED;
// @ts-ignore
          if (peg$silentFails === 0) { peg$fail(peg$e1); }
        }
      }
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "field_path",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "field_path",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsecte_name() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "cte_name",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 13;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "cte_name",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "cte_name",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = [];
// @ts-ignore
    if (peg$r1.test(input.charAt(peg$currPos))) {
// @ts-ignore
      s1 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s1 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e2); }
    }
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      while (s1 !== peg$FAILED) {
// @ts-ignore
        s0.push(s1);
// @ts-ignore
        if (peg$r1.test(input.charAt(peg$currPos))) {
// @ts-ignore
          s1 = input.charAt(peg$currPos);
// @ts-ignore
          peg$currPos++;
// @ts-ignore
        } else {
// @ts-ignore
          s1 = peg$FAILED;
// @ts-ignore
          if (peg$silentFails === 0) { peg$fail(peg$e2); }
        }
      }
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "cte_name",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "cte_name",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseas_alias() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "as_alias",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 14;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "as_alias",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "as_alias",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_AS();
// @ts-ignore
    if (s1 === peg$FAILED) {
// @ts-ignore
      s1 = null;
    }
// @ts-ignore
    s2 = peg$parse_();
// @ts-ignore
    s3 = peg$parsealias();
// @ts-ignore
    if (s3 !== peg$FAILED) {
// @ts-ignore
      s1 = [s1, s2, s3];
// @ts-ignore
      s0 = s1;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "as_alias",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "as_alias",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseunnest_operator() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "unnest_operator",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 15;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "unnest_operator",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "unnest_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$currPos;
// @ts-ignore
    s2 = peg$parseK_UNNEST();
// @ts-ignore
    if (s2 !== peg$FAILED) {
// @ts-ignore
      s3 = peg$parse_();
// @ts-ignore
      s4 = peg$parseLPAREN();
// @ts-ignore
      if (s4 !== peg$FAILED) {
// @ts-ignore
        s5 = peg$parse_();
// @ts-ignore
        s6 = peg$parsearray_expression();
// @ts-ignore
        if (s6 !== peg$FAILED) {
// @ts-ignore
          s7 = peg$parse_();
// @ts-ignore
          s8 = peg$parseRPAREN();
// @ts-ignore
          if (s8 !== peg$FAILED) {
// @ts-ignore
            s2 = [s2, s3, s4, s5, s6, s7, s8];
// @ts-ignore
            s1 = s2;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s1;
// @ts-ignore
            s1 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s1;
// @ts-ignore
          s1 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s1;
// @ts-ignore
        s1 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s1;
// @ts-ignore
      s1 = peg$FAILED;
    }
// @ts-ignore
    if (s1 === peg$FAILED) {
// @ts-ignore
      s1 = peg$currPos;
// @ts-ignore
      s2 = peg$parseK_UNNEST();
// @ts-ignore
      if (s2 !== peg$FAILED) {
// @ts-ignore
        s3 = peg$parse_();
// @ts-ignore
        s4 = peg$parseLPAREN();
// @ts-ignore
        if (s4 !== peg$FAILED) {
// @ts-ignore
          s5 = peg$parse_();
// @ts-ignore
          s6 = peg$parsearray_path();
// @ts-ignore
          if (s6 !== peg$FAILED) {
// @ts-ignore
            s7 = peg$parse_();
// @ts-ignore
            s8 = peg$parseRPAREN();
// @ts-ignore
            if (s8 !== peg$FAILED) {
// @ts-ignore
              s2 = [s2, s3, s4, s5, s6, s7, s8];
// @ts-ignore
              s1 = s2;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s1;
// @ts-ignore
              s1 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s1;
// @ts-ignore
            s1 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s1;
// @ts-ignore
          s1 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s1;
// @ts-ignore
        s1 = peg$FAILED;
      }
// @ts-ignore
      if (s1 === peg$FAILED) {
// @ts-ignore
        s1 = peg$parsearray_path();
      }
    }
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseas_alias();
// @ts-ignore
      if (s3 === peg$FAILED) {
// @ts-ignore
        s3 = null;
      }
// @ts-ignore
      s4 = peg$parse_();
// @ts-ignore
      s5 = peg$currPos;
// @ts-ignore
      s6 = peg$parseK_WITH();
// @ts-ignore
      if (s6 !== peg$FAILED) {
// @ts-ignore
        s7 = peg$parse_();
// @ts-ignore
        s8 = peg$parseK_OFFSET();
// @ts-ignore
        if (s8 !== peg$FAILED) {
// @ts-ignore
          s9 = peg$parse_();
// @ts-ignore
          s10 = peg$parseas_alias();
// @ts-ignore
          if (s10 === peg$FAILED) {
// @ts-ignore
            s10 = null;
          }
// @ts-ignore
          s6 = [s6, s7, s8, s9, s10];
// @ts-ignore
          s5 = s6;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s5;
// @ts-ignore
          s5 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s5;
// @ts-ignore
        s5 = peg$FAILED;
      }
// @ts-ignore
      if (s5 === peg$FAILED) {
// @ts-ignore
        s5 = null;
      }
// @ts-ignore
      s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
      s0 = s1;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "unnest_operator",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "unnest_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsearray_path() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "array_path",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 16;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "array_path",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "array_path",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5) === peg$c1) {
// @ts-ignore
      s0 = peg$c1;
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e3); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "array_path",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "array_path",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsearray_expression() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "array_expression",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 17;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "array_expression",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "array_expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 7) === peg$c2) {
// @ts-ignore
      s0 = peg$c2;
// @ts-ignore
      peg$currPos += 7;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e4); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "array_expression",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "array_expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsepivot_operator() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21, s22, s23, s24, s25, s26, s27, s28, s29, s30, s31, s32;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "pivot_operator",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 18;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "pivot_operator",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "pivot_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_PIVOT();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseLPAREN();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parseaggregate_function_call();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s6 = peg$parse_();
// @ts-ignore
          s7 = peg$parseas_alias();
// @ts-ignore
          if (s7 === peg$FAILED) {
// @ts-ignore
            s7 = null;
          }
// @ts-ignore
          s8 = peg$parse_();
// @ts-ignore
          s9 = peg$currPos;
// @ts-ignore
          s10 = peg$parseCOMMA();
// @ts-ignore
          if (s10 !== peg$FAILED) {
// @ts-ignore
            s11 = peg$parse_();
// @ts-ignore
            s10 = [s10, s11];
// @ts-ignore
            s9 = s10;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s9;
// @ts-ignore
            s9 = peg$FAILED;
          }
// @ts-ignore
          if (s9 === peg$FAILED) {
// @ts-ignore
            s9 = null;
          }
// @ts-ignore
          s10 = peg$parse_();
// @ts-ignore
          s11 = peg$parseK_FOR();
// @ts-ignore
          if (s11 !== peg$FAILED) {
// @ts-ignore
            s12 = peg$parse_();
// @ts-ignore
            s13 = peg$parseinput_column();
// @ts-ignore
            if (s13 !== peg$FAILED) {
// @ts-ignore
              s14 = peg$parse_();
// @ts-ignore
              s15 = peg$parseK_IN();
// @ts-ignore
              if (s15 !== peg$FAILED) {
// @ts-ignore
                s16 = peg$parse_();
// @ts-ignore
                s17 = peg$parseLPAREN();
// @ts-ignore
                if (s17 !== peg$FAILED) {
// @ts-ignore
                  s18 = peg$parse_();
// @ts-ignore
                  s19 = peg$parsepivot_column();
// @ts-ignore
                  if (s19 !== peg$FAILED) {
// @ts-ignore
                    s20 = peg$parse_();
// @ts-ignore
                    s21 = peg$parseas_alias();
// @ts-ignore
                    if (s21 === peg$FAILED) {
// @ts-ignore
                      s21 = null;
                    }
// @ts-ignore
                    s22 = peg$parse_();
// @ts-ignore
                    s23 = peg$currPos;
// @ts-ignore
                    s24 = peg$parseCOMMA();
// @ts-ignore
                    if (s24 !== peg$FAILED) {
// @ts-ignore
                      s25 = peg$parse_();
// @ts-ignore
                      s24 = [s24, s25];
// @ts-ignore
                      s23 = s24;
// @ts-ignore
                    } else {
// @ts-ignore
                      peg$currPos = s23;
// @ts-ignore
                      s23 = peg$FAILED;
                    }
// @ts-ignore
                    if (s23 === peg$FAILED) {
// @ts-ignore
                      s23 = null;
                    }
// @ts-ignore
                    s24 = peg$parse_();
// @ts-ignore
                    s25 = peg$parseRPAREN();
// @ts-ignore
                    if (s25 !== peg$FAILED) {
// @ts-ignore
                      s26 = peg$parse_();
// @ts-ignore
                      s27 = peg$parseRPAREN();
// @ts-ignore
                      if (s27 !== peg$FAILED) {
// @ts-ignore
                        s28 = peg$parse_();
// @ts-ignore
                        s29 = peg$currPos;
// @ts-ignore
                        s30 = peg$parseK_AS();
// @ts-ignore
                        if (s30 !== peg$FAILED) {
// @ts-ignore
                          s31 = peg$parse_();
// @ts-ignore
                          s32 = peg$parsealias();
// @ts-ignore
                          if (s32 !== peg$FAILED) {
// @ts-ignore
                            s30 = [s30, s31, s32];
// @ts-ignore
                            s29 = s30;
// @ts-ignore
                          } else {
// @ts-ignore
                            peg$currPos = s29;
// @ts-ignore
                            s29 = peg$FAILED;
                          }
// @ts-ignore
                        } else {
// @ts-ignore
                          peg$currPos = s29;
// @ts-ignore
                          s29 = peg$FAILED;
                        }
// @ts-ignore
                        if (s29 === peg$FAILED) {
// @ts-ignore
                          s29 = null;
                        }
// @ts-ignore
                        s1 = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21, s22, s23, s24, s25, s26, s27, s28, s29];
// @ts-ignore
                        s0 = s1;
// @ts-ignore
                      } else {
// @ts-ignore
                        peg$currPos = s0;
// @ts-ignore
                        s0 = peg$FAILED;
                      }
// @ts-ignore
                    } else {
// @ts-ignore
                      peg$currPos = s0;
// @ts-ignore
                      s0 = peg$FAILED;
                    }
// @ts-ignore
                  } else {
// @ts-ignore
                    peg$currPos = s0;
// @ts-ignore
                    s0 = peg$FAILED;
                  }
// @ts-ignore
                } else {
// @ts-ignore
                  peg$currPos = s0;
// @ts-ignore
                  s0 = peg$FAILED;
                }
// @ts-ignore
              } else {
// @ts-ignore
                peg$currPos = s0;
// @ts-ignore
                s0 = peg$FAILED;
              }
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s0;
// @ts-ignore
              s0 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "pivot_operator",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "pivot_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseaggregate_function_call() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "aggregate_function_call",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 19;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "aggregate_function_call",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "aggregate_function_call",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 10) === peg$c3) {
// @ts-ignore
      s0 = peg$c3;
// @ts-ignore
      peg$currPos += 10;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e5); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "aggregate_function_call",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "aggregate_function_call",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseinput_column() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "input_column",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 20;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "input_column",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "input_column",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 3) === peg$c4) {
// @ts-ignore
      s0 = peg$c4;
// @ts-ignore
      peg$currPos += 3;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e6); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "input_column",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "input_column",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsepivot_column() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "pivot_column",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 21;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "pivot_column",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "pivot_column",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 4) === peg$c5) {
// @ts-ignore
      s0 = peg$c5;
// @ts-ignore
      peg$currPos += 4;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e7); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "pivot_column",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "pivot_column",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseunpivot_operator() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "unpivot_operator",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 22;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "unpivot_operator",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "unpivot_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_UNPIVOT();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$currPos;
// @ts-ignore
      s4 = peg$parseK_INCLUDE();
// @ts-ignore
      if (s4 !== peg$FAILED) {
// @ts-ignore
        s5 = peg$parse_();
// @ts-ignore
        s6 = peg$parseK_NULLS();
// @ts-ignore
        if (s6 !== peg$FAILED) {
// @ts-ignore
          s4 = [s4, s5, s6];
// @ts-ignore
          s3 = s4;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s3;
// @ts-ignore
          s3 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s3;
// @ts-ignore
        s3 = peg$FAILED;
      }
// @ts-ignore
      if (s3 === peg$FAILED) {
// @ts-ignore
        s3 = peg$currPos;
// @ts-ignore
        s4 = peg$parseK_EXCLUDE();
// @ts-ignore
        if (s4 !== peg$FAILED) {
// @ts-ignore
          s5 = peg$parse_();
// @ts-ignore
          s6 = peg$parseK_NULLS();
// @ts-ignore
          if (s6 !== peg$FAILED) {
// @ts-ignore
            s4 = [s4, s5, s6];
// @ts-ignore
            s3 = s4;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s3;
// @ts-ignore
            s3 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s3;
// @ts-ignore
          s3 = peg$FAILED;
        }
      }
// @ts-ignore
      if (s3 === peg$FAILED) {
// @ts-ignore
        s3 = null;
      }
// @ts-ignore
      s4 = peg$parseLPAREN();
// @ts-ignore
      if (s4 !== peg$FAILED) {
// @ts-ignore
        s5 = peg$parse_();
// @ts-ignore
        s6 = peg$parsesingle_column_unpivot();
// @ts-ignore
        if (s6 === peg$FAILED) {
// @ts-ignore
          s6 = peg$parsemulti_column_unpivot();
        }
// @ts-ignore
        if (s6 !== peg$FAILED) {
// @ts-ignore
          s7 = peg$parse_();
// @ts-ignore
          s8 = peg$parseRPAREN();
// @ts-ignore
          if (s8 !== peg$FAILED) {
// @ts-ignore
            s9 = peg$parse_();
// @ts-ignore
            s10 = peg$parseunpivot_alias();
// @ts-ignore
            if (s10 === peg$FAILED) {
// @ts-ignore
              s10 = null;
            }
// @ts-ignore
            s1 = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10];
// @ts-ignore
            s0 = s1;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "unpivot_operator",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "unpivot_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsesingle_column_unpivot() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "single_column_unpivot",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 23;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "single_column_unpivot",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "single_column_unpivot",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parsevalues_column();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_FOR();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parsename_column();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s6 = peg$parse_();
// @ts-ignore
          s7 = peg$parseK_IN();
// @ts-ignore
          if (s7 !== peg$FAILED) {
// @ts-ignore
            s8 = peg$parse_();
// @ts-ignore
            s9 = peg$parseLPAREN();
// @ts-ignore
            if (s9 !== peg$FAILED) {
// @ts-ignore
              s10 = peg$parse_();
// @ts-ignore
              s11 = peg$parsecolumns_to_unpivot();
// @ts-ignore
              if (s11 !== peg$FAILED) {
// @ts-ignore
                s12 = peg$parse_();
// @ts-ignore
                s13 = peg$parseRPAREN();
// @ts-ignore
                if (s13 !== peg$FAILED) {
// @ts-ignore
                  s1 = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13];
// @ts-ignore
                  s0 = s1;
// @ts-ignore
                } else {
// @ts-ignore
                  peg$currPos = s0;
// @ts-ignore
                  s0 = peg$FAILED;
                }
// @ts-ignore
              } else {
// @ts-ignore
                peg$currPos = s0;
// @ts-ignore
                s0 = peg$FAILED;
              }
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s0;
// @ts-ignore
              s0 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "single_column_unpivot",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "single_column_unpivot",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsevalues_column() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "values_column",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 24;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "values_column",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "values_column",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 3) === peg$c4) {
// @ts-ignore
      s0 = peg$c4;
// @ts-ignore
      peg$currPos += 3;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e6); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "values_column",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "values_column",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsename_column() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "name_column",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 25;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "name_column",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "name_column",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 3) === peg$c4) {
// @ts-ignore
      s0 = peg$c4;
// @ts-ignore
      peg$currPos += 3;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e6); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "name_column",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "name_column",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsemulti_column_unpivot() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "multi_column_unpivot",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 26;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "multi_column_unpivot",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "multi_column_unpivot",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parsevalues_column_set();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_FOR();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parsename_column();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s6 = peg$parse_();
// @ts-ignore
          s7 = peg$parseK_IN();
// @ts-ignore
          if (s7 !== peg$FAILED) {
// @ts-ignore
            s8 = peg$parse_();
// @ts-ignore
            s9 = peg$parseLPAREN();
// @ts-ignore
            if (s9 !== peg$FAILED) {
// @ts-ignore
              s10 = peg$parse_();
// @ts-ignore
              s11 = peg$parsecolumn_sets_to_unpivot();
// @ts-ignore
              if (s11 !== peg$FAILED) {
// @ts-ignore
                s12 = peg$parse_();
// @ts-ignore
                s13 = peg$parseRPAREN();
// @ts-ignore
                if (s13 !== peg$FAILED) {
// @ts-ignore
                  s1 = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13];
// @ts-ignore
                  s0 = s1;
// @ts-ignore
                } else {
// @ts-ignore
                  peg$currPos = s0;
// @ts-ignore
                  s0 = peg$FAILED;
                }
// @ts-ignore
              } else {
// @ts-ignore
                peg$currPos = s0;
// @ts-ignore
                s0 = peg$FAILED;
              }
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s0;
// @ts-ignore
              s0 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "multi_column_unpivot",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "multi_column_unpivot",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsevalues_column_set() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "values_column_set",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 27;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "values_column_set",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "values_column_set",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseLPAREN();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = [];
// @ts-ignore
      s3 = peg$parsevalues_column();
// @ts-ignore
      while (s3 !== peg$FAILED) {
// @ts-ignore
        s2.push(s3);
// @ts-ignore
        s3 = peg$currPos;
// @ts-ignore
        s4 = peg$currPos;
// @ts-ignore
        s5 = peg$parse_();
// @ts-ignore
        s6 = peg$parseCOMMA();
// @ts-ignore
        if (s6 !== peg$FAILED) {
// @ts-ignore
          s7 = peg$parse_();
// @ts-ignore
          s5 = [s5, s6, s7];
// @ts-ignore
          s4 = s5;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s4;
// @ts-ignore
          s4 = peg$FAILED;
        }
// @ts-ignore
        if (s4 !== peg$FAILED) {
// @ts-ignore
          s4 = peg$parsevalues_column();
// @ts-ignore
          if (s4 === peg$FAILED) {
// @ts-ignore
            peg$currPos = s3;
// @ts-ignore
            s3 = peg$FAILED;
// @ts-ignore
          } else {
// @ts-ignore
            s3 = s4;
          }
// @ts-ignore
        } else {
// @ts-ignore
          s3 = s4;
        }
      }
// @ts-ignore
      s3 = peg$parseRPAREN();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s1 = [s1, s2, s3];
// @ts-ignore
        s0 = s1;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "values_column_set",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "values_column_set",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsejoin_operation() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "join_operation",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 28;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "join_operation",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "join_operation",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$parsecross_join_operation();
// @ts-ignore
    if (s0 === peg$FAILED) {
// @ts-ignore
      s0 = peg$parsecondition_join_operation();
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "join_operation",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "join_operation",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsecolumns_to_unpivot() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "columns_to_unpivot",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 29;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "columns_to_unpivot",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "columns_to_unpivot",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseunpivot_column();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = [];
// @ts-ignore
      s4 = peg$parserow_value_alias();
// @ts-ignore
      while (s4 !== peg$FAILED) {
// @ts-ignore
        s3.push(s4);
// @ts-ignore
        s4 = peg$currPos;
// @ts-ignore
        s5 = peg$currPos;
// @ts-ignore
        s6 = peg$parse_();
// @ts-ignore
        s7 = peg$parseCOMMA();
// @ts-ignore
        if (s7 !== peg$FAILED) {
// @ts-ignore
          s8 = peg$parse_();
// @ts-ignore
          s6 = [s6, s7, s8];
// @ts-ignore
          s5 = s6;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s5;
// @ts-ignore
          s5 = peg$FAILED;
        }
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s5 = peg$parserow_value_alias();
// @ts-ignore
          if (s5 === peg$FAILED) {
// @ts-ignore
            peg$currPos = s4;
// @ts-ignore
            s4 = peg$FAILED;
// @ts-ignore
          } else {
// @ts-ignore
            s4 = s5;
          }
// @ts-ignore
        } else {
// @ts-ignore
          s4 = s5;
        }
      }
// @ts-ignore
      s1 = [s1, s2, s3];
// @ts-ignore
      s0 = s1;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "columns_to_unpivot",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "columns_to_unpivot",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseunpivot_column() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "unpivot_column",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 30;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "unpivot_column",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "unpivot_column",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 3) === peg$c4) {
// @ts-ignore
      s0 = peg$c4;
// @ts-ignore
      peg$currPos += 3;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e6); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "unpivot_column",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "unpivot_column",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsecolumn_sets_to_unpivot() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "column_sets_to_unpivot",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 31;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "column_sets_to_unpivot",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "column_sets_to_unpivot",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseLPAREN();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseunpivot_column();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = [];
// @ts-ignore
        s6 = peg$parserow_value_alias();
// @ts-ignore
        while (s6 !== peg$FAILED) {
// @ts-ignore
          s5.push(s6);
// @ts-ignore
          s6 = peg$currPos;
// @ts-ignore
          s7 = peg$currPos;
// @ts-ignore
          s8 = peg$parse_();
// @ts-ignore
          s9 = peg$parseCOMMA();
// @ts-ignore
          if (s9 !== peg$FAILED) {
// @ts-ignore
            s10 = peg$parse_();
// @ts-ignore
            s8 = [s8, s9, s10];
// @ts-ignore
            s7 = s8;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s7;
// @ts-ignore
            s7 = peg$FAILED;
          }
// @ts-ignore
          if (s7 !== peg$FAILED) {
// @ts-ignore
            s7 = peg$parserow_value_alias();
// @ts-ignore
            if (s7 === peg$FAILED) {
// @ts-ignore
              peg$currPos = s6;
// @ts-ignore
              s6 = peg$FAILED;
// @ts-ignore
            } else {
// @ts-ignore
              s6 = s7;
            }
// @ts-ignore
          } else {
// @ts-ignore
            s6 = s7;
          }
        }
// @ts-ignore
        s6 = peg$parse_();
// @ts-ignore
        s7 = peg$parseRPAREN();
// @ts-ignore
        if (s7 !== peg$FAILED) {
// @ts-ignore
          s1 = [s1, s2, s3, s4, s5, s6, s7];
// @ts-ignore
          s0 = s1;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "column_sets_to_unpivot",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "column_sets_to_unpivot",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseunpivot_alias() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "unpivot_alias",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 32;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "unpivot_alias",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "unpivot_alias",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_AS();
// @ts-ignore
    if (s1 === peg$FAILED) {
// @ts-ignore
      s1 = null;
    }
// @ts-ignore
    s2 = peg$parse_();
// @ts-ignore
    s3 = peg$parsealias();
// @ts-ignore
    if (s3 !== peg$FAILED) {
// @ts-ignore
      s1 = [s1, s2, s3];
// @ts-ignore
      s0 = s1;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "unpivot_alias",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "unpivot_alias",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parserow_value_alias() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "row_value_alias",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 33;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "row_value_alias",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "row_value_alias",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_AS();
// @ts-ignore
    if (s1 === peg$FAILED) {
// @ts-ignore
      s1 = null;
    }
// @ts-ignore
    s2 = peg$parse_();
// @ts-ignore
    s3 = peg$parsealias();
// @ts-ignore
    if (s3 !== peg$FAILED) {
// @ts-ignore
      s1 = [s1, s2, s3];
// @ts-ignore
      s0 = s1;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "row_value_alias",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "row_value_alias",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsetablesample_operator() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "tablesample_operator",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 34;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "tablesample_operator",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "tablesample_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_TABLESAMPLE();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_SYSTEM();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parseLPAREN();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s6 = peg$parse_();
// @ts-ignore
          s7 = peg$parsepercent();
// @ts-ignore
          if (s7 !== peg$FAILED) {
// @ts-ignore
            s8 = peg$parse_();
// @ts-ignore
            s9 = peg$parseK_PERCENT();
// @ts-ignore
            if (s9 !== peg$FAILED) {
// @ts-ignore
              s10 = peg$parse_();
// @ts-ignore
              s11 = peg$parseRPAREN();
// @ts-ignore
              if (s11 !== peg$FAILED) {
// @ts-ignore
                s1 = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
// @ts-ignore
                s0 = s1;
// @ts-ignore
              } else {
// @ts-ignore
                peg$currPos = s0;
// @ts-ignore
                s0 = peg$FAILED;
              }
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s0;
// @ts-ignore
              s0 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "tablesample_operator",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "tablesample_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsepercent() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "percent",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 35;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "percent",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "percent",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = [];
// @ts-ignore
    if (peg$r2.test(input.charAt(peg$currPos))) {
// @ts-ignore
      s1 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s1 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e8); }
    }
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      while (s1 !== peg$FAILED) {
// @ts-ignore
        s0.push(s1);
// @ts-ignore
        if (peg$r2.test(input.charAt(peg$currPos))) {
// @ts-ignore
          s1 = input.charAt(peg$currPos);
// @ts-ignore
          peg$currPos++;
// @ts-ignore
        } else {
// @ts-ignore
          s1 = peg$FAILED;
// @ts-ignore
          if (peg$silentFails === 0) { peg$fail(peg$e8); }
        }
      }
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "percent",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "percent",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsecross_join_operation() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "cross_join_operation",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 36;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "cross_join_operation",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "cross_join_operation",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parsefrom_item();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parsecross_join_operator();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parsefrom_item();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
          s0 = s1;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "cross_join_operation",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "cross_join_operation",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsecondition_join_operation() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "condition_join_operation",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 37;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "condition_join_operation",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "condition_join_operation",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parsefrom_item();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parsecondition_join_operator();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parsefrom_item();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s6 = peg$parse_();
// @ts-ignore
          s7 = peg$parsejoin_condition();
// @ts-ignore
          if (s7 !== peg$FAILED) {
// @ts-ignore
            s1 = [s1, s2, s3, s4, s5, s6, s7];
// @ts-ignore
            s0 = s1;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "condition_join_operation",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "condition_join_operation",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsecross_join_operator() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "cross_join_operator",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 38;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "cross_join_operator",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "cross_join_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_CROSS();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_JOIN();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s1 = [s1, s2, s3];
// @ts-ignore
        s0 = s1;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }
// @ts-ignore
    if (s0 === peg$FAILED) {
// @ts-ignore
      s0 = peg$parseCOMMA();
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "cross_join_operator",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "cross_join_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsecondition_join_operator() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "condition_join_operator",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 39;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "condition_join_operator",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "condition_join_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_INNER();
// @ts-ignore
    if (s1 === peg$FAILED) {
// @ts-ignore
      s1 = null;
    }
// @ts-ignore
    s2 = peg$parse_();
// @ts-ignore
    s3 = peg$parseK_JOIN();
// @ts-ignore
    if (s3 !== peg$FAILED) {
// @ts-ignore
      s1 = [s1, s2, s3];
// @ts-ignore
      s0 = s1;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }
// @ts-ignore
    if (s0 === peg$FAILED) {
// @ts-ignore
      s0 = peg$currPos;
// @ts-ignore
      s1 = peg$parseK_FULL();
// @ts-ignore
      if (s1 !== peg$FAILED) {
// @ts-ignore
        s2 = peg$parse_();
// @ts-ignore
        s3 = peg$parseK_OUTER();
// @ts-ignore
        if (s3 === peg$FAILED) {
// @ts-ignore
          s3 = null;
        }
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parseK_JOIN();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
          s0 = s1;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
      if (s0 === peg$FAILED) {
// @ts-ignore
        s0 = peg$currPos;
// @ts-ignore
        s1 = peg$parseK_LEFT();
// @ts-ignore
        if (s1 !== peg$FAILED) {
// @ts-ignore
          s2 = peg$parse_();
// @ts-ignore
          s3 = peg$parseK_OUTER();
// @ts-ignore
          if (s3 === peg$FAILED) {
// @ts-ignore
            s3 = null;
          }
// @ts-ignore
          s4 = peg$parse_();
// @ts-ignore
          s5 = peg$parseK_JOIN();
// @ts-ignore
          if (s5 !== peg$FAILED) {
// @ts-ignore
            s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
            s0 = s1;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
        if (s0 === peg$FAILED) {
// @ts-ignore
          s0 = peg$currPos;
// @ts-ignore
          s1 = peg$parseK_RIGHT();
// @ts-ignore
          if (s1 !== peg$FAILED) {
// @ts-ignore
            s2 = peg$parse_();
// @ts-ignore
            s3 = peg$parseK_OUTER();
// @ts-ignore
            if (s3 === peg$FAILED) {
// @ts-ignore
              s3 = null;
            }
// @ts-ignore
            s4 = peg$parse_();
// @ts-ignore
            s5 = peg$parseK_JOIN();
// @ts-ignore
            if (s5 !== peg$FAILED) {
// @ts-ignore
              s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
              s0 = s1;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s0;
// @ts-ignore
              s0 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
        }
      }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "condition_join_operator",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "condition_join_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsejoin_condition() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "join_condition",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 40;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "join_condition",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "join_condition",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$parseon_clause();
// @ts-ignore
    if (s0 === peg$FAILED) {
// @ts-ignore
      s0 = peg$parseusing_clause();
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "join_condition",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "join_condition",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseon_clause() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "on_clause",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 41;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "on_clause",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "on_clause",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_ON();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parsebool_expression();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s1 = [s1, s2, s3];
// @ts-ignore
        s0 = s1;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "on_clause",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "on_clause",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseusing_clause() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "using_clause",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 42;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "using_clause",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "using_clause",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_USING();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseLPAREN();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parsecolumn_list();
// @ts-ignore
        s6 = peg$parse_();
// @ts-ignore
        s7 = peg$parseRPAREN();
// @ts-ignore
        if (s7 !== peg$FAILED) {
// @ts-ignore
          s1 = [s1, s2, s3, s4, s5, s6, s7];
// @ts-ignore
          s0 = s1;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "using_clause",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "using_clause",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsecolumn_list() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "column_list",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 43;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "column_list",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "column_list",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = [];
// @ts-ignore
    s1 = peg$parsecolumn_name();
// @ts-ignore
    while (s1 !== peg$FAILED) {
// @ts-ignore
      s0.push(s1);
// @ts-ignore
      s1 = peg$currPos;
// @ts-ignore
      s2 = peg$currPos;
// @ts-ignore
      s3 = peg$parse_();
// @ts-ignore
      s4 = peg$parseCOMMA();
// @ts-ignore
      if (s4 !== peg$FAILED) {
// @ts-ignore
        s5 = peg$parse_();
// @ts-ignore
        s3 = [s3, s4, s5];
// @ts-ignore
        s2 = s3;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s2;
// @ts-ignore
        s2 = peg$FAILED;
      }
// @ts-ignore
      if (s2 !== peg$FAILED) {
// @ts-ignore
        s2 = peg$parsecolumn_name();
// @ts-ignore
        if (s2 === peg$FAILED) {
// @ts-ignore
          peg$currPos = s1;
// @ts-ignore
          s1 = peg$FAILED;
// @ts-ignore
        } else {
// @ts-ignore
          s1 = s2;
        }
// @ts-ignore
      } else {
// @ts-ignore
        s1 = s2;
      }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "column_list",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "column_list",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsegroup_by_specification() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "group_by_specification",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 44;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "group_by_specification",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "group_by_specification",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$parsegroupable_items();

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "group_by_specification",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "group_by_specification",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsegrouping_sets_specification() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "grouping_sets_specification",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 45;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "grouping_sets_specification",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "grouping_sets_specification",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 11) === peg$c6) {
// @ts-ignore
      s0 = peg$c6;
// @ts-ignore
      peg$currPos += 11;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e9); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "grouping_sets_specification",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "grouping_sets_specification",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parserollup_specification() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "rollup_specification",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 46;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "rollup_specification",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "rollup_specification",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 13) === peg$c7) {
// @ts-ignore
      s0 = peg$c7;
// @ts-ignore
      peg$currPos += 13;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e10); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "rollup_specification",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "rollup_specification",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsecube_specification() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "cube_specification",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 47;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "cube_specification",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "cube_specification",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 7) === peg$c8) {
// @ts-ignore
      s0 = peg$c8;
// @ts-ignore
      peg$currPos += 7;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e11); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "cube_specification",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "cube_specification",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsegroupable_items() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "groupable_items",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 48;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "groupable_items",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "groupable_items",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = [];
// @ts-ignore
    s1 = peg$parseexpression();
// @ts-ignore
    while (s1 !== peg$FAILED) {
// @ts-ignore
      s0.push(s1);
// @ts-ignore
      s1 = peg$currPos;
// @ts-ignore
      s2 = peg$currPos;
// @ts-ignore
      s3 = peg$parse_();
// @ts-ignore
      s4 = peg$parseCOMMA();
// @ts-ignore
      if (s4 !== peg$FAILED) {
// @ts-ignore
        s5 = peg$parse_();
// @ts-ignore
        s3 = [s3, s4, s5];
// @ts-ignore
        s2 = s3;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s2;
// @ts-ignore
        s2 = peg$FAILED;
      }
// @ts-ignore
      if (s2 !== peg$FAILED) {
// @ts-ignore
        s2 = peg$parseexpression();
// @ts-ignore
        if (s2 === peg$FAILED) {
// @ts-ignore
          peg$currPos = s1;
// @ts-ignore
          s1 = peg$FAILED;
// @ts-ignore
        } else {
// @ts-ignore
          s1 = s2;
        }
// @ts-ignore
      } else {
// @ts-ignore
        s1 = s2;
      }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "groupable_items",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "groupable_items",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsewindow_clause() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "window_clause",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 49;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "window_clause",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "window_clause",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = [];
// @ts-ignore
    s1 = peg$parsenamed_window_expression();
// @ts-ignore
    while (s1 !== peg$FAILED) {
// @ts-ignore
      s0.push(s1);
// @ts-ignore
      s1 = peg$currPos;
// @ts-ignore
      s2 = peg$currPos;
// @ts-ignore
      s3 = peg$parse_();
// @ts-ignore
      s4 = peg$parseCOMMA();
// @ts-ignore
      if (s4 !== peg$FAILED) {
// @ts-ignore
        s5 = peg$parse_();
// @ts-ignore
        s3 = [s3, s4, s5];
// @ts-ignore
        s2 = s3;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s2;
// @ts-ignore
        s2 = peg$FAILED;
      }
// @ts-ignore
      if (s2 !== peg$FAILED) {
// @ts-ignore
        s2 = peg$parsenamed_window_expression();
// @ts-ignore
        if (s2 === peg$FAILED) {
// @ts-ignore
          peg$currPos = s1;
// @ts-ignore
          s1 = peg$FAILED;
// @ts-ignore
        } else {
// @ts-ignore
          s1 = s2;
        }
// @ts-ignore
      } else {
// @ts-ignore
        s1 = s2;
      }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "window_clause",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "window_clause",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsenamed_window_expression() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "named_window_expression",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 50;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "named_window_expression",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "named_window_expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parsenamed_window();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_AS();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parsenamed_window();
// @ts-ignore
        if (s5 === peg$FAILED) {
// @ts-ignore
          s5 = peg$currPos;
// @ts-ignore
          s6 = peg$parseLPAREN();
// @ts-ignore
          if (s6 !== peg$FAILED) {
// @ts-ignore
            s7 = peg$parse_();
// @ts-ignore
            s8 = peg$parsewindow_specification();
// @ts-ignore
            s9 = peg$parse_();
// @ts-ignore
            s10 = peg$parseRPAREN();
// @ts-ignore
            if (s10 !== peg$FAILED) {
// @ts-ignore
              s6 = [s6, s7, s8, s9, s10];
// @ts-ignore
              s5 = s6;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s5;
// @ts-ignore
              s5 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s5;
// @ts-ignore
            s5 = peg$FAILED;
          }
        }
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
          s0 = s1;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "named_window_expression",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "named_window_expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsenamed_window() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "named_window",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 51;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "named_window",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "named_window",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 11) === peg$c9) {
// @ts-ignore
      s0 = peg$c9;
// @ts-ignore
      peg$currPos += 11;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e12); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "named_window",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "named_window",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsewindow_specification() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "window_specification",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 52;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "window_specification",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "window_specification",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parsenamed_window();
// @ts-ignore
    if (s1 === peg$FAILED) {
// @ts-ignore
      s1 = null;
    }
// @ts-ignore
    s2 = peg$parse_();
// @ts-ignore
    s3 = peg$currPos;
// @ts-ignore
    s4 = peg$parseK_PARTITION();
// @ts-ignore
    if (s4 !== peg$FAILED) {
// @ts-ignore
      s5 = peg$parse_();
// @ts-ignore
      s6 = peg$parseK_BY();
// @ts-ignore
      if (s6 !== peg$FAILED) {
// @ts-ignore
        s7 = peg$parse_();
// @ts-ignore
        s8 = [];
// @ts-ignore
        s9 = peg$parsepartition_expression();
// @ts-ignore
        while (s9 !== peg$FAILED) {
// @ts-ignore
          s8.push(s9);
// @ts-ignore
          s9 = peg$currPos;
// @ts-ignore
          s10 = peg$currPos;
// @ts-ignore
          s11 = peg$parse_();
// @ts-ignore
          s12 = peg$parseCOMMA();
// @ts-ignore
          if (s12 !== peg$FAILED) {
// @ts-ignore
            s13 = peg$parse_();
// @ts-ignore
            s11 = [s11, s12, s13];
// @ts-ignore
            s10 = s11;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s10;
// @ts-ignore
            s10 = peg$FAILED;
          }
// @ts-ignore
          if (s10 !== peg$FAILED) {
// @ts-ignore
            s10 = peg$parsepartition_expression();
// @ts-ignore
            if (s10 === peg$FAILED) {
// @ts-ignore
              peg$currPos = s9;
// @ts-ignore
              s9 = peg$FAILED;
// @ts-ignore
            } else {
// @ts-ignore
              s9 = s10;
            }
// @ts-ignore
          } else {
// @ts-ignore
            s9 = s10;
          }
        }
// @ts-ignore
        s4 = [s4, s5, s6, s7, s8];
// @ts-ignore
        s3 = s4;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s3;
// @ts-ignore
        s3 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s3;
// @ts-ignore
      s3 = peg$FAILED;
    }
// @ts-ignore
    if (s3 === peg$FAILED) {
// @ts-ignore
      s3 = null;
    }
// @ts-ignore
    s4 = peg$parse_();
// @ts-ignore
    s5 = peg$currPos;
// @ts-ignore
    s6 = peg$parseK_ORDER();
// @ts-ignore
    if (s6 !== peg$FAILED) {
// @ts-ignore
      s7 = peg$parse_();
// @ts-ignore
      s8 = peg$parseK_BY();
// @ts-ignore
      if (s8 !== peg$FAILED) {
// @ts-ignore
        s9 = peg$parse_();
// @ts-ignore
        s10 = peg$parseexpression();
// @ts-ignore
        if (s10 !== peg$FAILED) {
// @ts-ignore
          s11 = peg$parse_();
// @ts-ignore
          s12 = [];
// @ts-ignore
          s13 = peg$parseK_ASC();
// @ts-ignore
          if (s13 === peg$FAILED) {
// @ts-ignore
            s13 = peg$parseK_DESC();
          }
// @ts-ignore
          while (s13 !== peg$FAILED) {
// @ts-ignore
            s12.push(s13);
// @ts-ignore
            s13 = peg$currPos;
// @ts-ignore
            s14 = peg$currPos;
// @ts-ignore
            s15 = peg$parse_();
// @ts-ignore
            s16 = peg$parseCOMMA();
// @ts-ignore
            if (s16 !== peg$FAILED) {
// @ts-ignore
              s17 = peg$parse_();
// @ts-ignore
              s15 = [s15, s16, s17];
// @ts-ignore
              s14 = s15;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s14;
// @ts-ignore
              s14 = peg$FAILED;
            }
// @ts-ignore
            if (s14 !== peg$FAILED) {
// @ts-ignore
              s14 = peg$parseK_ASC();
// @ts-ignore
              if (s14 === peg$FAILED) {
// @ts-ignore
                s14 = peg$parseK_DESC();
              }
// @ts-ignore
              if (s14 === peg$FAILED) {
// @ts-ignore
                peg$currPos = s13;
// @ts-ignore
                s13 = peg$FAILED;
// @ts-ignore
              } else {
// @ts-ignore
                s13 = s14;
              }
// @ts-ignore
            } else {
// @ts-ignore
              s13 = s14;
            }
          }
// @ts-ignore
          s6 = [s6, s7, s8, s9, s10, s11, s12];
// @ts-ignore
          s5 = s6;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s5;
// @ts-ignore
          s5 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s5;
// @ts-ignore
        s5 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s5;
// @ts-ignore
      s5 = peg$FAILED;
    }
// @ts-ignore
    if (s5 === peg$FAILED) {
// @ts-ignore
      s5 = null;
    }
// @ts-ignore
    s6 = peg$parse_();
// @ts-ignore
    s7 = peg$parsewindow_frame_clause();
// @ts-ignore
    if (s7 === peg$FAILED) {
// @ts-ignore
      s7 = null;
    }
// @ts-ignore
    s1 = [s1, s2, s3, s4, s5, s6, s7];
// @ts-ignore
    s0 = s1;

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "window_specification",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "window_specification",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsepartition_expression() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "partition_expression",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 53;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "partition_expression",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "partition_expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 3) === peg$c4) {
// @ts-ignore
      s0 = peg$c4;
// @ts-ignore
      peg$currPos += 3;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e6); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "partition_expression",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "partition_expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsewindow_frame_clause() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "window_frame_clause",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 54;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "window_frame_clause",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "window_frame_clause",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parserows_range();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseframe_start();
// @ts-ignore
      if (s3 === peg$FAILED) {
// @ts-ignore
        s3 = peg$parseframe_between();
      }
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s1 = [s1, s2, s3];
// @ts-ignore
        s0 = s1;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "window_frame_clause",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "window_frame_clause",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parserows_range() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "rows_range",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 55;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "rows_range",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "rows_range",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_ROWS();
// @ts-ignore
    if (s1 === peg$FAILED) {
// @ts-ignore
      s1 = peg$parseK_RANGE();
    }
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s1 = [s1, s2];
// @ts-ignore
      s0 = s1;
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "rows_range",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "rows_range",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseframe_between() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "frame_between",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 56;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "frame_between",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "frame_between",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_BETWEEN();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$currPos;
// @ts-ignore
      s4 = peg$parseunbounded_preceding();
// @ts-ignore
      if (s4 !== peg$FAILED) {
// @ts-ignore
        s5 = peg$parse_();
// @ts-ignore
        s6 = peg$parseK_AND();
// @ts-ignore
        if (s6 !== peg$FAILED) {
// @ts-ignore
          s7 = peg$parse_();
// @ts-ignore
          s8 = peg$parseframe_end_a();
// @ts-ignore
          if (s8 !== peg$FAILED) {
// @ts-ignore
            s4 = [s4, s5, s6, s7, s8];
// @ts-ignore
            s3 = s4;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s3;
// @ts-ignore
            s3 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s3;
// @ts-ignore
          s3 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s3;
// @ts-ignore
        s3 = peg$FAILED;
      }
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s1 = [s1, s2, s3];
// @ts-ignore
        s0 = s1;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }
// @ts-ignore
    if (s0 === peg$FAILED) {
// @ts-ignore
      s0 = peg$currPos;
// @ts-ignore
      s1 = peg$parsenumeric_preceding();
// @ts-ignore
      if (s1 !== peg$FAILED) {
// @ts-ignore
        s2 = peg$parse_();
// @ts-ignore
        s3 = peg$parseK_AND();
// @ts-ignore
        if (s3 !== peg$FAILED) {
// @ts-ignore
          s4 = peg$parse_();
// @ts-ignore
          s5 = peg$parseframe_end_a();
// @ts-ignore
          if (s5 !== peg$FAILED) {
// @ts-ignore
            s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
            s0 = s1;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
      if (s0 === peg$FAILED) {
// @ts-ignore
        s0 = peg$currPos;
// @ts-ignore
        s1 = peg$parsecurrent_row();
// @ts-ignore
        if (s1 !== peg$FAILED) {
// @ts-ignore
          s2 = peg$parse_();
// @ts-ignore
          s3 = peg$parseK_AND();
// @ts-ignore
          if (s3 !== peg$FAILED) {
// @ts-ignore
            s4 = peg$parse_();
// @ts-ignore
            s5 = peg$parseframe_end_b();
// @ts-ignore
            if (s5 !== peg$FAILED) {
// @ts-ignore
              s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
              s0 = s1;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s0;
// @ts-ignore
              s0 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
      }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "frame_between",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "frame_between",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseframe_start() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "frame_start",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 57;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "frame_start",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "frame_start",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$parseunbounded_preceding();
// @ts-ignore
    if (s0 === peg$FAILED) {
// @ts-ignore
      s0 = peg$parsenumeric_preceding();
// @ts-ignore
      if (s0 === peg$FAILED) {
// @ts-ignore
        s0 = peg$parsecurrent_row();
// @ts-ignore
        if (s0 === peg$FAILED) {
// @ts-ignore
          s0 = null;
        }
      }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "frame_start",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "frame_start",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseframe_end_a() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "frame_end_a",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 58;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "frame_end_a",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "frame_end_a",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$parsenumeric_preceding();
// @ts-ignore
    if (s0 === peg$FAILED) {
// @ts-ignore
      s0 = peg$parsecurrent_row();
// @ts-ignore
      if (s0 === peg$FAILED) {
// @ts-ignore
        s0 = peg$parsenumeric_following();
// @ts-ignore
        if (s0 === peg$FAILED) {
// @ts-ignore
          s0 = peg$parseunbounded_following();
        }
      }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "frame_end_a",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "frame_end_a",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseframe_end_b() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "frame_end_b",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 59;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "frame_end_b",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "frame_end_b",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$parsecurrent_row();
// @ts-ignore
    if (s0 === peg$FAILED) {
// @ts-ignore
      s0 = peg$parsenumeric_following();
// @ts-ignore
      if (s0 === peg$FAILED) {
// @ts-ignore
        s0 = peg$parseunbounded_following();
      }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "frame_end_b",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "frame_end_b",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseframe_end_c() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "frame_end_c",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 60;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "frame_end_c",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "frame_end_c",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$parsenumeric_following();
// @ts-ignore
    if (s0 === peg$FAILED) {
// @ts-ignore
      s0 = peg$parseunbounded_following();
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "frame_end_c",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "frame_end_c",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseunbounded_preceding() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "unbounded_preceding",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 61;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "unbounded_preceding",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "unbounded_preceding",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_UNBOUNDED();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_PRECEDING();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s1 = [s1, s2, s3];
// @ts-ignore
        s0 = s1;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "unbounded_preceding",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "unbounded_preceding",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsenumeric_preceding() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "numeric_preceding",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 62;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "numeric_preceding",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "numeric_preceding",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseexpression();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_PRECEDING();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s1 = [s1, s2, s3];
// @ts-ignore
        s0 = s1;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "numeric_preceding",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "numeric_preceding",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseunbounded_following() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "unbounded_following",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 63;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "unbounded_following",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "unbounded_following",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_UNBOUNDED();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_FOLLOWING();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s1 = [s1, s2, s3];
// @ts-ignore
        s0 = s1;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "unbounded_following",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "unbounded_following",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsenumeric_following() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "numeric_following",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 64;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "numeric_following",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "numeric_following",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseexpression();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_FOLLOWING();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s1 = [s1, s2, s3];
// @ts-ignore
        s0 = s1;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "numeric_following",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "numeric_following",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsecurrent_row() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "current_row",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 65;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "current_row",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "current_row",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_CURRENT();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_ROW();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s1 = [s1, s2, s3];
// @ts-ignore
        s0 = s1;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "current_row",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "current_row",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseset_operator() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "set_operator",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 66;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "set_operator",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "set_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_UNION();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_ALL();
// @ts-ignore
      if (s3 === peg$FAILED) {
// @ts-ignore
        s3 = peg$parseK_DISTINCT();
      }
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s1 = [s1, s2, s3];
// @ts-ignore
        s0 = s1;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }
// @ts-ignore
    if (s0 === peg$FAILED) {
// @ts-ignore
      s0 = peg$currPos;
// @ts-ignore
      s1 = peg$parseK_INTERSECT();
// @ts-ignore
      if (s1 !== peg$FAILED) {
// @ts-ignore
        s2 = peg$parse_();
// @ts-ignore
        s3 = peg$parseK_DISTINCT();
// @ts-ignore
        if (s3 !== peg$FAILED) {
// @ts-ignore
          s1 = [s1, s2, s3];
// @ts-ignore
          s0 = s1;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
      if (s0 === peg$FAILED) {
// @ts-ignore
        s0 = peg$currPos;
// @ts-ignore
        s1 = peg$parseK_EXCEPT();
// @ts-ignore
        if (s1 !== peg$FAILED) {
// @ts-ignore
          s2 = peg$parse_();
// @ts-ignore
          s3 = peg$parseK_DISTINCT();
// @ts-ignore
          if (s3 !== peg$FAILED) {
// @ts-ignore
            s1 = [s1, s2, s3];
// @ts-ignore
            s0 = s1;
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
      }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "set_operator",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "set_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsenon_recursive_cte() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "non_recursive_cte",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 67;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "non_recursive_cte",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "non_recursive_cte",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parsecte_name();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_AS();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parseLPAREN();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s6 = peg$parse_();
// @ts-ignore
          s7 = peg$parsequery_expr();
// @ts-ignore
          if (s7 !== peg$FAILED) {
// @ts-ignore
            s8 = peg$parse_();
// @ts-ignore
            s9 = peg$parseRPAREN();
// @ts-ignore
            if (s9 !== peg$FAILED) {
// @ts-ignore
              s1 = [s1, s2, s3, s4, s5, s6, s7, s8, s9];
// @ts-ignore
              s0 = s1;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s0;
// @ts-ignore
              s0 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "non_recursive_cte",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "non_recursive_cte",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parserecursive_cte() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "recursive_cte",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 68;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "recursive_cte",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "recursive_cte",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parsecte_name();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_AS();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parseLPAREN();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s6 = peg$parse_();
// @ts-ignore
          s7 = peg$parserecursive_union_operation();
// @ts-ignore
          if (s7 !== peg$FAILED) {
// @ts-ignore
            s8 = peg$parse_();
// @ts-ignore
            s9 = peg$parseRPAREN();
// @ts-ignore
            if (s9 !== peg$FAILED) {
// @ts-ignore
              s1 = [s1, s2, s3, s4, s5, s6, s7, s8, s9];
// @ts-ignore
              s0 = s1;
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s0;
// @ts-ignore
              s0 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "recursive_cte",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "recursive_cte",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parserecursive_union_operation() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "recursive_union_operation",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 69;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "recursive_union_operation",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "recursive_union_operation",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parsequery_expr();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseunion_operator();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parsequery_expr();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s1 = [s1, s2, s3, s4, s5];
// @ts-ignore
          s0 = s1;
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "recursive_union_operation",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "recursive_union_operation",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseunion_operator() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "union_operator",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 70;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "union_operator",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "union_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_UNION();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_ALL();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s1 = [s1, s2, s3];
// @ts-ignore
        s0 = s1;
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "union_operator",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "union_operator",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsedifferential_privacy_clause() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "differential_privacy_clause",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 71;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "differential_privacy_clause",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "differential_privacy_clause",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    s1 = peg$parseK_WITH();
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseK_DIFFERENTIAL_PRIVACY();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parseK_OPTIONS();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s6 = peg$parse_();
// @ts-ignore
          s7 = peg$parseLPAREN();
// @ts-ignore
          if (s7 !== peg$FAILED) {
// @ts-ignore
            s8 = peg$parse_();
// @ts-ignore
            s9 = peg$parseprivacy_parameters();
// @ts-ignore
            if (s9 !== peg$FAILED) {
// @ts-ignore
              s10 = peg$parse_();
// @ts-ignore
              s11 = peg$parseRPAREN();
// @ts-ignore
              if (s11 !== peg$FAILED) {
// @ts-ignore
                s1 = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
// @ts-ignore
                s0 = s1;
// @ts-ignore
              } else {
// @ts-ignore
                peg$currPos = s0;
// @ts-ignore
                s0 = peg$FAILED;
              }
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s0;
// @ts-ignore
              s0 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "differential_privacy_clause",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "differential_privacy_clause",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseprivacy_parameters() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21, s22, s23, s24;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "privacy_parameters",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 72;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "privacy_parameters",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "privacy_parameters",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = peg$currPos;
// @ts-ignore
    if (input.substr(peg$currPos, 7) === peg$c10) {
// @ts-ignore
      s1 = peg$c10;
// @ts-ignore
      peg$currPos += 7;
// @ts-ignore
    } else {
// @ts-ignore
      s1 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e13); }
    }
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      s2 = peg$parse_();
// @ts-ignore
      s3 = peg$parseEQUAL();
// @ts-ignore
      if (s3 !== peg$FAILED) {
// @ts-ignore
        s4 = peg$parse_();
// @ts-ignore
        s5 = peg$parseexpression();
// @ts-ignore
        if (s5 !== peg$FAILED) {
// @ts-ignore
          s6 = peg$parse_();
// @ts-ignore
          s7 = peg$parseCOMMA();
// @ts-ignore
          if (s7 !== peg$FAILED) {
// @ts-ignore
            s8 = peg$parse_();
// @ts-ignore
            if (input.substr(peg$currPos, 5) === peg$c11) {
// @ts-ignore
              s9 = peg$c11;
// @ts-ignore
              peg$currPos += 5;
// @ts-ignore
            } else {
// @ts-ignore
              s9 = peg$FAILED;
// @ts-ignore
              if (peg$silentFails === 0) { peg$fail(peg$e14); }
            }
// @ts-ignore
            if (s9 !== peg$FAILED) {
// @ts-ignore
              s10 = peg$parse_();
// @ts-ignore
              s11 = peg$parseEQUAL();
// @ts-ignore
              if (s11 !== peg$FAILED) {
// @ts-ignore
                s12 = peg$parse_();
// @ts-ignore
                s13 = peg$parseexpression();
// @ts-ignore
                if (s13 !== peg$FAILED) {
// @ts-ignore
                  s14 = peg$parse_();
// @ts-ignore
                  s15 = peg$parseCOMMA();
// @ts-ignore
                  if (s15 !== peg$FAILED) {
// @ts-ignore
                    s16 = peg$parse_();
// @ts-ignore
                    s17 = peg$currPos;
// @ts-ignore
                    if (input.substr(peg$currPos, 22) === peg$c12) {
// @ts-ignore
                      s18 = peg$c12;
// @ts-ignore
                      peg$currPos += 22;
// @ts-ignore
                    } else {
// @ts-ignore
                      s18 = peg$FAILED;
// @ts-ignore
                      if (peg$silentFails === 0) { peg$fail(peg$e15); }
                    }
// @ts-ignore
                    if (s18 !== peg$FAILED) {
// @ts-ignore
                      s19 = peg$parse_();
// @ts-ignore
                      s20 = peg$parseEQUAL();
// @ts-ignore
                      if (s20 !== peg$FAILED) {
// @ts-ignore
                        s21 = peg$parse_();
// @ts-ignore
                        s22 = peg$parseexpression();
// @ts-ignore
                        if (s22 !== peg$FAILED) {
// @ts-ignore
                          s23 = peg$parse_();
// @ts-ignore
                          s24 = peg$parseCOMMA();
// @ts-ignore
                          if (s24 !== peg$FAILED) {
// @ts-ignore
                            s18 = [s18, s19, s20, s21, s22, s23, s24];
// @ts-ignore
                            s17 = s18;
// @ts-ignore
                          } else {
// @ts-ignore
                            peg$currPos = s17;
// @ts-ignore
                            s17 = peg$FAILED;
                          }
// @ts-ignore
                        } else {
// @ts-ignore
                          peg$currPos = s17;
// @ts-ignore
                          s17 = peg$FAILED;
                        }
// @ts-ignore
                      } else {
// @ts-ignore
                        peg$currPos = s17;
// @ts-ignore
                        s17 = peg$FAILED;
                      }
// @ts-ignore
                    } else {
// @ts-ignore
                      peg$currPos = s17;
// @ts-ignore
                      s17 = peg$FAILED;
                    }
// @ts-ignore
                    if (s17 === peg$FAILED) {
// @ts-ignore
                      s17 = null;
                    }
// @ts-ignore
                    s18 = peg$parse_();
// @ts-ignore
                    if (input.substr(peg$currPos, 19) === peg$c13) {
// @ts-ignore
                      s19 = peg$c13;
// @ts-ignore
                      peg$currPos += 19;
// @ts-ignore
                    } else {
// @ts-ignore
                      s19 = peg$FAILED;
// @ts-ignore
                      if (peg$silentFails === 0) { peg$fail(peg$e16); }
                    }
// @ts-ignore
                    if (s19 !== peg$FAILED) {
// @ts-ignore
                      s20 = peg$parse_();
// @ts-ignore
                      s21 = peg$parseEQUAL();
// @ts-ignore
                      if (s21 !== peg$FAILED) {
// @ts-ignore
                        s22 = peg$parse_();
// @ts-ignore
                        s23 = peg$parsecolumn_name();
// @ts-ignore
                        if (s23 !== peg$FAILED) {
// @ts-ignore
                          s1 = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21, s22, s23];
// @ts-ignore
                          s0 = s1;
// @ts-ignore
                        } else {
// @ts-ignore
                          peg$currPos = s0;
// @ts-ignore
                          s0 = peg$FAILED;
                        }
// @ts-ignore
                      } else {
// @ts-ignore
                        peg$currPos = s0;
// @ts-ignore
                        s0 = peg$FAILED;
                      }
// @ts-ignore
                    } else {
// @ts-ignore
                      peg$currPos = s0;
// @ts-ignore
                      s0 = peg$FAILED;
                    }
// @ts-ignore
                  } else {
// @ts-ignore
                    peg$currPos = s0;
// @ts-ignore
                    s0 = peg$FAILED;
                  }
// @ts-ignore
                } else {
// @ts-ignore
                  peg$currPos = s0;
// @ts-ignore
                  s0 = peg$FAILED;
                }
// @ts-ignore
              } else {
// @ts-ignore
                peg$currPos = s0;
// @ts-ignore
                s0 = peg$FAILED;
              }
// @ts-ignore
            } else {
// @ts-ignore
              peg$currPos = s0;
// @ts-ignore
              s0 = peg$FAILED;
            }
// @ts-ignore
          } else {
// @ts-ignore
            peg$currPos = s0;
// @ts-ignore
            s0 = peg$FAILED;
          }
// @ts-ignore
        } else {
// @ts-ignore
          peg$currPos = s0;
// @ts-ignore
          s0 = peg$FAILED;
        }
// @ts-ignore
      } else {
// @ts-ignore
        peg$currPos = s0;
// @ts-ignore
        s0 = peg$FAILED;
      }
// @ts-ignore
    } else {
// @ts-ignore
      peg$currPos = s0;
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "privacy_parameters",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "privacy_parameters",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseexpression() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "expression",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 73;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "expression",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 1).toLowerCase() === peg$c14) {
// @ts-ignore
      s0 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e17); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "expression",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsebool_expression() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "bool_expression",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 74;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "bool_expression",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "bool_expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c15) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 4);
// @ts-ignore
      peg$currPos += 4;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e18); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "bool_expression",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "bool_expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsecolumn_name() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "column_name",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 75;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "column_name",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "column_name",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = [];
// @ts-ignore
    if (peg$r1.test(input.charAt(peg$currPos))) {
// @ts-ignore
      s1 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s1 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e2); }
    }
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      while (s1 !== peg$FAILED) {
// @ts-ignore
        s0.push(s1);
// @ts-ignore
        if (peg$r1.test(input.charAt(peg$currPos))) {
// @ts-ignore
          s1 = input.charAt(peg$currPos);
// @ts-ignore
          peg$currPos++;
// @ts-ignore
        } else {
// @ts-ignore
          s1 = peg$FAILED;
// @ts-ignore
          if (peg$silentFails === 0) { peg$fail(peg$e2); }
        }
      }
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "column_name",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "column_name",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsealias() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "alias",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 76;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "alias",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "alias",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = [];
// @ts-ignore
    if (peg$r1.test(input.charAt(peg$currPos))) {
// @ts-ignore
      s1 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s1 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e2); }
    }
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      while (s1 !== peg$FAILED) {
// @ts-ignore
        s0.push(s1);
// @ts-ignore
        if (peg$r1.test(input.charAt(peg$currPos))) {
// @ts-ignore
          s1 = input.charAt(peg$currPos);
// @ts-ignore
          peg$currPos++;
// @ts-ignore
        } else {
// @ts-ignore
          s1 = peg$FAILED;
// @ts-ignore
          if (peg$silentFails === 0) { peg$fail(peg$e2); }
        }
      }
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "alias",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "alias",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsetable_name() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "table_name",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 77;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "table_name",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "table_name",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    s0 = [];
// @ts-ignore
    if (peg$r1.test(input.charAt(peg$currPos))) {
// @ts-ignore
      s1 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s1 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e2); }
    }
// @ts-ignore
    if (s1 !== peg$FAILED) {
// @ts-ignore
      while (s1 !== peg$FAILED) {
// @ts-ignore
        s0.push(s1);
// @ts-ignore
        if (peg$r1.test(input.charAt(peg$currPos))) {
// @ts-ignore
          s1 = input.charAt(peg$currPos);
// @ts-ignore
          peg$currPos++;
// @ts-ignore
        } else {
// @ts-ignore
          s1 = peg$FAILED;
// @ts-ignore
          if (peg$silentFails === 0) { peg$fail(peg$e2); }
        }
      }
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "table_name",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "table_name",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parsetimestamp_expression() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "timestamp_expression",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 78;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "timestamp_expression",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "timestamp_expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 1).toLowerCase() === peg$c14) {
// @ts-ignore
      s0 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e17); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "timestamp_expression",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "timestamp_expression",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parse_() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0, s1;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "_",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 79;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "_",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "_",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    peg$silentFails++;
// @ts-ignore
    s0 = [];
// @ts-ignore
    if (peg$r3.test(input.charAt(peg$currPos))) {
// @ts-ignore
      s1 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s1 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e20); }
    }
// @ts-ignore
    while (s1 !== peg$FAILED) {
// @ts-ignore
      s0.push(s1);
// @ts-ignore
      if (peg$r3.test(input.charAt(peg$currPos))) {
// @ts-ignore
        s1 = input.charAt(peg$currPos);
// @ts-ignore
        peg$currPos++;
// @ts-ignore
      } else {
// @ts-ignore
        s1 = peg$FAILED;
// @ts-ignore
        if (peg$silentFails === 0) { peg$fail(peg$e20); }
      }
    }
// @ts-ignore
    peg$silentFails--;
// @ts-ignore
    s1 = peg$FAILED;
// @ts-ignore
    if (peg$silentFails === 0) { peg$fail(peg$e19); }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "_",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "_",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_AND() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_AND",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 80;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_AND",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_AND",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c16) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 3);
// @ts-ignore
      peg$currPos += 3;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e21); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_AND",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_AND",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_ALL() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_ALL",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 81;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_ALL",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_ALL",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c17) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 3);
// @ts-ignore
      peg$currPos += 3;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e22); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_ALL",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_ALL",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_AS() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_AS",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 82;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_AS",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_AS",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c18) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 2);
// @ts-ignore
      peg$currPos += 2;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e23); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_AS",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_AS",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_ASC() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_ASC",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 83;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_ASC",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_ASC",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c19) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 3);
// @ts-ignore
      peg$currPos += 3;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e24); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_ASC",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_ASC",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_BETWEEN() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_BETWEEN",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 84;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_BETWEEN",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_BETWEEN",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c20) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 7);
// @ts-ignore
      peg$currPos += 7;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e25); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_BETWEEN",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_BETWEEN",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_BY() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_BY",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 85;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_BY",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_BY",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c21) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 2);
// @ts-ignore
      peg$currPos += 2;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e26); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_BY",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_BY",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_CURRENT() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_CURRENT",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 86;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_CURRENT",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_CURRENT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c22) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 7);
// @ts-ignore
      peg$currPos += 7;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e27); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_CURRENT",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_CURRENT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_CROSS() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_CROSS",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 87;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_CROSS",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_CROSS",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c23) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e28); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_CROSS",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_CROSS",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_DESC() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_DESC",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 88;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_DESC",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_DESC",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c24) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 4);
// @ts-ignore
      peg$currPos += 4;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e29); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_DESC",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_DESC",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_DIFFERENTIAL_PRIVACY() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_DIFFERENTIAL_PRIVACY",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 89;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_DIFFERENTIAL_PRIVACY",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_DIFFERENTIAL_PRIVACY",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 20).toLowerCase() === peg$c25) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 20);
// @ts-ignore
      peg$currPos += 20;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e30); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_DIFFERENTIAL_PRIVACY",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_DIFFERENTIAL_PRIVACY",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_DISTINCT() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_DISTINCT",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 90;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_DISTINCT",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_DISTINCT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c26) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 8);
// @ts-ignore
      peg$currPos += 8;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e31); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_DISTINCT",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_DISTINCT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_EXCEPT() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_EXCEPT",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 91;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_EXCEPT",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_EXCEPT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c27) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 6);
// @ts-ignore
      peg$currPos += 6;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e32); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_EXCEPT",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_EXCEPT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_EXCLUDE() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_EXCLUDE",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 92;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_EXCLUDE",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_EXCLUDE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c28) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 7);
// @ts-ignore
      peg$currPos += 7;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e33); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_EXCLUDE",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_EXCLUDE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_FOR() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_FOR",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 93;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_FOR",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_FOR",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c29) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 3);
// @ts-ignore
      peg$currPos += 3;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e34); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_FOR",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_FOR",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_FOLLOWING() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_FOLLOWING",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 94;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_FOLLOWING",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_FOLLOWING",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c30) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 9);
// @ts-ignore
      peg$currPos += 9;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e35); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_FOLLOWING",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_FOLLOWING",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_FROM() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_FROM",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 95;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_FROM",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_FROM",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c31) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 4);
// @ts-ignore
      peg$currPos += 4;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e36); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_FROM",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_FROM",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_FULL() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_FULL",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 96;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_FULL",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_FULL",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c32) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 4);
// @ts-ignore
      peg$currPos += 4;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e37); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_FULL",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_FULL",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_GROUP() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_GROUP",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 97;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_GROUP",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_GROUP",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c33) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e38); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_GROUP",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_GROUP",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_HAVING() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_HAVING",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 98;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_HAVING",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_HAVING",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c34) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 6);
// @ts-ignore
      peg$currPos += 6;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e39); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_HAVING",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_HAVING",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_IN() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_IN",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 99;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_IN",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_IN",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c35) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 2);
// @ts-ignore
      peg$currPos += 2;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e40); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_IN",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_IN",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_INCLUDE() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_INCLUDE",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 100;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_INCLUDE",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_INCLUDE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c36) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 7);
// @ts-ignore
      peg$currPos += 7;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e41); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_INCLUDE",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_INCLUDE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_INNER() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_INNER",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 101;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_INNER",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_INNER",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c37) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e42); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_INNER",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_INNER",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_INTERSECT() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_INTERSECT",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 102;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_INTERSECT",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_INTERSECT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c38) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 9);
// @ts-ignore
      peg$currPos += 9;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e43); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_INTERSECT",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_INTERSECT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_JOIN() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_JOIN",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 103;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_JOIN",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_JOIN",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c39) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 4);
// @ts-ignore
      peg$currPos += 4;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e44); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_JOIN",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_JOIN",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_LEFT() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_LEFT",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 104;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_LEFT",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_LEFT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c40) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 4);
// @ts-ignore
      peg$currPos += 4;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e45); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_LEFT",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_LEFT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_LIMIT() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_LIMIT",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 105;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_LIMIT",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_LIMIT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c41) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e46); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_LIMIT",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_LIMIT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_NULLS() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_NULLS",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 106;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_NULLS",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_NULLS",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c42) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e47); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_NULLS",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_NULLS",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_OF() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_OF",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 107;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_OF",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_OF",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c43) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 2);
// @ts-ignore
      peg$currPos += 2;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e48); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_OF",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_OF",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_OFFSET() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_OFFSET",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 108;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_OFFSET",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_OFFSET",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c44) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 6);
// @ts-ignore
      peg$currPos += 6;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e49); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_OFFSET",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_OFFSET",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_ON() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_ON",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 109;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_ON",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_ON",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c45) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 2);
// @ts-ignore
      peg$currPos += 2;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e50); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_ON",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_ON",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_OPTIONS() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_OPTIONS",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 110;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_OPTIONS",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_OPTIONS",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c46) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 7);
// @ts-ignore
      peg$currPos += 7;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e51); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_OPTIONS",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_OPTIONS",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_ORDER() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_ORDER",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 111;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_ORDER",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_ORDER",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c47) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e52); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_ORDER",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_ORDER",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_OUTER() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_OUTER",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 112;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_OUTER",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_OUTER",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c48) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e53); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_OUTER",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_OUTER",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_PARTITION() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_PARTITION",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 113;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_PARTITION",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_PARTITION",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c49) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 9);
// @ts-ignore
      peg$currPos += 9;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e54); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_PARTITION",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_PARTITION",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_PERCENT() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_PERCENT",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 114;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_PERCENT",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_PERCENT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c50) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 7);
// @ts-ignore
      peg$currPos += 7;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e55); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_PERCENT",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_PERCENT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_PRECEDING() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_PRECEDING",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 115;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_PRECEDING",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_PRECEDING",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c51) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 9);
// @ts-ignore
      peg$currPos += 9;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e56); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_PRECEDING",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_PRECEDING",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_PIVOT() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_PIVOT",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 116;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_PIVOT",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_PIVOT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c52) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e57); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_PIVOT",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_PIVOT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_QUALIFY() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_QUALIFY",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 117;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_QUALIFY",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_QUALIFY",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c53) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 7);
// @ts-ignore
      peg$currPos += 7;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e58); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_QUALIFY",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_QUALIFY",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_RANGE() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_RANGE",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 118;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_RANGE",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_RANGE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c54) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e59); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_RANGE",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_RANGE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_RECURSIVE() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_RECURSIVE",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 119;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_RECURSIVE",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_RECURSIVE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c55) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 9);
// @ts-ignore
      peg$currPos += 9;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e60); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_RECURSIVE",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_RECURSIVE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_REPLACE() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_REPLACE",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 120;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_REPLACE",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_REPLACE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c56) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 7);
// @ts-ignore
      peg$currPos += 7;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e61); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_REPLACE",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_REPLACE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_ROW() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_ROW",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 121;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_ROW",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_ROW",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c57) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 3);
// @ts-ignore
      peg$currPos += 3;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e62); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_ROW",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_ROW",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_ROWS() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_ROWS",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 122;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_ROWS",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_ROWS",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c58) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 4);
// @ts-ignore
      peg$currPos += 4;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e63); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_ROWS",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_ROWS",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_RIGHT() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_RIGHT",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 123;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_RIGHT",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_RIGHT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c59) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e64); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_RIGHT",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_RIGHT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_SELECT() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_SELECT",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 124;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_SELECT",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_SELECT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c60) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 6);
// @ts-ignore
      peg$currPos += 6;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e65); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_SELECT",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_SELECT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_STRUCT() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_STRUCT",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 125;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_STRUCT",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_STRUCT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c61) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 6);
// @ts-ignore
      peg$currPos += 6;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e66); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_STRUCT",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_STRUCT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_SYSTEM() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_SYSTEM",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 126;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_SYSTEM",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_SYSTEM",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c62) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 6);
// @ts-ignore
      peg$currPos += 6;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e67); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_SYSTEM",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_SYSTEM",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_SYSTEM_TIME() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_SYSTEM_TIME",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 127;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_SYSTEM_TIME",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_SYSTEM_TIME",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 11).toLowerCase() === peg$c63) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 11);
// @ts-ignore
      peg$currPos += 11;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e68); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_SYSTEM_TIME",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_SYSTEM_TIME",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_TABLESAMPLE() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_TABLESAMPLE",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 128;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_TABLESAMPLE",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_TABLESAMPLE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 11).toLowerCase() === peg$c64) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 11);
// @ts-ignore
      peg$currPos += 11;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e69); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_TABLESAMPLE",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_TABLESAMPLE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_UNBOUNDED() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_UNBOUNDED",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 129;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_UNBOUNDED",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_UNBOUNDED",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c65) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 9);
// @ts-ignore
      peg$currPos += 9;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e70); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_UNBOUNDED",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_UNBOUNDED",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_UNION() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_UNION",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 130;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_UNION",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_UNION",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c66) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e71); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_UNION",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_UNION",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_UNNEST() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_UNNEST",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 131;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_UNNEST",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_UNNEST",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c67) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 6);
// @ts-ignore
      peg$currPos += 6;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e72); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_UNNEST",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_UNNEST",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_UNPIVOT() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_UNPIVOT",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 132;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_UNPIVOT",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_UNPIVOT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c68) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 7);
// @ts-ignore
      peg$currPos += 7;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e73); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_UNPIVOT",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_UNPIVOT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_USING() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_USING",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 133;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_USING",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_USING",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c69) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e74); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_USING",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_USING",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_VALUE() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_VALUE",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 134;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_VALUE",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_VALUE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c70) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e75); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_VALUE",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_VALUE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_WHERE() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_WHERE",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 135;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_WHERE",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_WHERE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c71) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 5);
// @ts-ignore
      peg$currPos += 5;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e76); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_WHERE",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_WHERE",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_WINDOW() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_WINDOW",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 136;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_WINDOW",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_WINDOW",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c72) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 6);
// @ts-ignore
      peg$currPos += 6;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e77); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_WINDOW",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_WINDOW",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseK_WITH() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "K_WITH",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 137;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_WITH",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_WITH",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c73) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 4);
// @ts-ignore
      peg$currPos += 4;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e78); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "K_WITH",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "K_WITH",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseLPAREN() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "LPAREN",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 138;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "LPAREN",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "LPAREN",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 1).toLowerCase() === peg$c74) {
// @ts-ignore
      s0 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e79); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "LPAREN",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "LPAREN",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseRPAREN() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "RPAREN",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 139;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "RPAREN",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "RPAREN",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 1).toLowerCase() === peg$c75) {
// @ts-ignore
      s0 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e80); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "RPAREN",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "RPAREN",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseLPAREN_RPAREN() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "LPAREN_RPAREN",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 140;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "LPAREN_RPAREN",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "LPAREN_RPAREN",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c76) {
// @ts-ignore
      s0 = input.substr(peg$currPos, 2);
// @ts-ignore
      peg$currPos += 2;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e81); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "LPAREN_RPAREN",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "LPAREN_RPAREN",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseEQUAL() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "EQUAL",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 141;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "EQUAL",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "EQUAL",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 1).toLowerCase() === peg$c77) {
// @ts-ignore
      s0 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e82); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "EQUAL",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "EQUAL",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseCOMMA() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "COMMA",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 142;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "COMMA",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "COMMA",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 1).toLowerCase() === peg$c78) {
// @ts-ignore
      s0 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e83); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "COMMA",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "COMMA",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  function // @ts-ignore
peg$parseDOT() {
// @ts-ignore
    var startPos = peg$currPos;
// @ts-ignore
    var s0;

// @ts-ignore
    peg$tracer.trace({
// @ts-ignore
      type: "rule.enter",
// @ts-ignore
      rule: "DOT",
// @ts-ignore
      location: peg$computeLocation(startPos, startPos, true)
    });

// @ts-ignore
    var key = peg$currPos * 144 + 143;
// @ts-ignore
    var cached = peg$resultsCache[key];

// @ts-ignore
    if (cached) {
// @ts-ignore
      peg$currPos = cached.nextPos;

// @ts-ignore
    if (cached.result !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "DOT",
// @ts-ignore
        result: cached.result,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "DOT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
      return cached.result;
    }

// @ts-ignore
    if (input.substr(peg$currPos, 1).toLowerCase() === peg$c79) {
// @ts-ignore
      s0 = input.charAt(peg$currPos);
// @ts-ignore
      peg$currPos++;
// @ts-ignore
    } else {
// @ts-ignore
      s0 = peg$FAILED;
// @ts-ignore
      if (peg$silentFails === 0) { peg$fail(peg$e84); }
    }

// @ts-ignore
    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

// @ts-ignore
    if (s0 !== peg$FAILED) {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.match",
// @ts-ignore
        rule: "DOT",
// @ts-ignore
        result: s0,
// @ts-ignore
        location: peg$computeLocation(startPos, peg$currPos, true)
      });
// @ts-ignore
    } else {
// @ts-ignore
      peg$tracer.trace({
// @ts-ignore
        type: "rule.fail",
// @ts-ignore
        rule: "DOT",
// @ts-ignore
        location: peg$computeLocation(startPos, startPos, true)
      });
    }

// @ts-ignore
    return s0;
  }

// @ts-ignore
  peg$result = peg$startRuleFunction();

// @ts-ignore
  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
// @ts-ignore
    return peg$result;
// @ts-ignore
  } else {
// @ts-ignore
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
// @ts-ignore
      peg$fail(peg$endExpectation());
    }

// @ts-ignore
    throw peg$buildStructuredError(
// @ts-ignore
      peg$maxFailExpected,
// @ts-ignore
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
// @ts-ignore
      peg$maxFailPos < input.length
// @ts-ignore
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
// @ts-ignore
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

// @ts-ignore
  return {
    SyntaxError: peg$SyntaxError,
    DefaultTracer: peg$DefaultTracer,
    parse: peg$parse
  };
})()

export interface FilePosition {
  offset: number;
  line: number;
  column: number;
}

export interface FileRange {
  start: FilePosition;
  end: FilePosition;
  source: string;
}

export interface LiteralExpectation {
  type: "literal";
  text: string;
  ignoreCase: boolean;
}

export interface ClassParts extends Array<string | ClassParts> {}

export interface ClassExpectation {
  type: "class";
  parts: ClassParts;
  inverted: boolean;
  ignoreCase: boolean;
}

export interface AnyExpectation {
  type: "any";
}

export interface EndExpectation {
  type: "end";
}

export interface OtherExpectation {
  type: "other";
  description: string;
}

export type Expectation = LiteralExpectation | ClassExpectation | AnyExpectation | EndExpectation | OtherExpectation;

declare class _PeggySyntaxError extends Error {
  public static buildMessage(expected: Expectation[], found: string | null): string;
  public message: string;
  public expected: Expectation[];
  public found: string | null;
  public location: FileRange;
  public name: string;
  constructor(message: string, expected: Expectation[], found: string | null, location: FileRange);
  format(sources: {
    source?: any;
    text: string;
  }[]): string;
}

export interface TraceEvent {
    type: string;
    rule: string;
    result?: any;
    location: FileRange;
  }

declare class _DefaultTracer {
  private indentLevel: number;
  public trace(event: TraceEvent): void;
}

peggyParser.SyntaxError.prototype.name = "PeggySyntaxError";

export interface ParseOptions {
  filename?: string;
  startRule?: "query_statement";
  tracer?: any;
  [key: string]: any;
}
export type ParseFunction = <Options extends ParseOptions>(
    input: string,
    options?: Options
  ) => Options extends { startRule: infer StartRule } ?
    StartRule extends "query_statement" ? QueryStatement : QueryStatement
    : QueryStatement;
export const parse: ParseFunction = peggyParser.parse;

export const PeggySyntaxError = peggyParser.SyntaxError as typeof _PeggySyntaxError;

export type PeggySyntaxError = _PeggySyntaxError;

export const DefaultTracer = peggyParser.DefaultTracer as typeof _DefaultTracer;

export type DefaultTracer = _DefaultTracer;

// These types were autogenerated by ts-pegjs
export type QueryStatement = QueryExpr;
export type QueryExpr = [
  [KWITH, _, KRECURSIVE | null, _, (NonRecursiveCte | RecursiveCte)[]] | null,
  _,
  QueryExpr02[]
];
export type QueryExpr02 = [
  [LPAREN, _, QueryExpr, _, RPAREN] | Select,
  _,
  [KORDER, _, KBY, _, Expression, _, (KASC | KDESC) | null][],
  _,
  [KLIMIT, _, Expression, _, [KOFFSET, _, Expression] | null] | null
];
export type Select = [
  KSELECT,
  _,
  [KWITH, _, DifferentialPrivacyClause] | null,
  _,
  (KALL | KDISTINCT) | null,
  _,
  [KAS, _, KSTRUCT | KVALUE] | null,
  _,
  SelectList,
  _,
  [KFROM, _, FromClause[]] | null,
  _,
  [KWHERE, _, BoolExpression] | null,
  _,
  [KGROUP, _, KBY, _, GroupBySpecification] | null,
  _,
  [KHAVING, _, BoolExpression] | null,
  _,
  [KQUALIFY, _, BoolExpression] | null,
  _,
  [KWINDOW, _, WindowClause] | null
];
export type SelectList = (SelectAll | SelectExpression)[];
export type SelectAll = [
  [Expression, _, DOT] | null,
  _,
  "*",
  _,
  [KEXCEPT, _, LPAREN, _, ColumnName[], RPAREN] | null,
  _,
  (
    | [
        KREPLACE,
        _,
        LPAREN,
        _,
        [Expression, _, KAS | null, _, ColumnName][],
        _,
        RPAREN
      ]
    | null
  )
];
export type SelectExpression = [Expression, _, [KAS | null, _, Alias] | null];
export type FromClause = [
  FromItem,
  _,
  (PivotOperator | UnpivotOperator) | null,
  _,
  TablesampleOperator | null
];
export type FromItem = FromItemWithoutJoin | FromItemWithJoin;
export type FromItemWithJoin = [
  FromItemWithJoinWithParen,
  _,
  CrossJoinOperator | ConditionJoinOperator,
  _,
  FromItemWithJoinWithParen
];
export type FromItemWithJoinWithParen =
  | [LPAREN, _, FromItem, _, RPAREN]
  | FromItemWithoutJoin;
export type FromItemWithoutJoin =
  | [
      TableName,
      _,
      AsAlias | null,
      _,
      [KFOR, _, KSYSTEMTIME, _, KAS, _, KOF, _, TimestampExpression] | null
    ]
  | [LPAREN, _, QueryExpr, _, RPAREN, _, AsAlias | null]
  | FieldPath
  | UnnestOperator
  | [CteName, _, AsAlias | null];
export type FieldPath = string[];
export type CteName = string[];
export type AsAlias = [KAS | null, _, Alias];
export type UnnestOperator = [
  (
    | [KUNNEST, _, LPAREN, _, ArrayExpression, _, RPAREN]
    | [KUNNEST, _, LPAREN, _, ArrayPath, _, RPAREN]
    | ArrayPath
  ),
  _,
  AsAlias | null,
  _,
  [KWITH, _, KOFFSET, _, AsAlias | null] | null
];
export type ArrayPath = "a.ary";
export type ArrayExpression = "[1,2,3]";
export type PivotOperator = [
  KPIVOT,
  _,
  LPAREN,
  _,
  AggregateFunctionCall,
  _,
  AsAlias | null,
  _,
  [COMMA, _] | null,
  _,
  KFOR,
  _,
  InputColumn,
  _,
  KIN,
  _,
  LPAREN,
  _,
  PivotColumn,
  _,
  AsAlias | null,
  _,
  [COMMA, _] | null,
  _,
  RPAREN,
  _,
  RPAREN,
  _,
  [KAS, _, Alias] | null
];
export type AggregateFunctionCall = "SUM(sales)";
export type InputColumn = "col";
export type PivotColumn = "'Q1'";
export type UnpivotOperator = [
  KUNPIVOT,
  _,
  ([KINCLUDE, _, KNULLS] | [KEXCLUDE, _, KNULLS]) | null,
  LPAREN,
  _,
  SingleColumnUnpivot | MultiColumnUnpivot,
  _,
  RPAREN,
  _,
  UnpivotAlias | null
];
export type SingleColumnUnpivot = [
  ValuesColumn,
  _,
  KFOR,
  _,
  NameColumn,
  _,
  KIN,
  _,
  LPAREN,
  _,
  ColumnsToUnpivot,
  _,
  RPAREN
];
export type ValuesColumn = "col";
export type NameColumn = "col";
export type MultiColumnUnpivot = [
  ValuesColumnSet,
  _,
  KFOR,
  _,
  NameColumn,
  _,
  KIN,
  _,
  LPAREN,
  _,
  ColumnSetsToUnpivot,
  _,
  RPAREN
];
export type ValuesColumnSet = [LPAREN, ValuesColumn[], RPAREN];
export type JoinOperation = CrossJoinOperation | ConditionJoinOperation;
export type ColumnsToUnpivot = [UnpivotColumn, _, RowValueAlias[] | null];
export type UnpivotColumn = "col";
export type ColumnSetsToUnpivot = [
  LPAREN,
  _,
  UnpivotColumn,
  _,
  RowValueAlias[] | null,
  _,
  RPAREN
];
export type UnpivotAlias = [KAS | null, _, Alias];
export type RowValueAlias = [KAS | null, _, Alias];
export type TablesampleOperator = [
  KTABLESAMPLE,
  _,
  KSYSTEM,
  _,
  LPAREN,
  _,
  Percent,
  _,
  KPERCENT,
  _,
  RPAREN
];
export type Percent = string[];
export type CrossJoinOperation = [FromItem, _, CrossJoinOperator, _, FromItem];
export type ConditionJoinOperation = [
  FromItem,
  _,
  ConditionJoinOperator,
  _,
  FromItem,
  _,
  JoinCondition
];
export type CrossJoinOperator = [KCROSS, _, KJOIN] | COMMA;
export type ConditionJoinOperator =
  | [KINNER | null, _, KJOIN]
  | [KFULL, _, KOUTER | null, _, KJOIN]
  | [KLEFT, _, KOUTER | null, _, KJOIN]
  | [KRIGHT, _, KOUTER | null, _, KJOIN];
export type JoinCondition = OnClause | UsingClause;
export type OnClause = [KON, _, BoolExpression];
export type UsingClause = [KUSING, _, LPAREN, _, ColumnList, _, RPAREN];
export type ColumnList = ColumnName[];
export type GroupBySpecification =
  | GroupableItems
  | GroupingSetsSpecification
  | RollupSpecification
  | CubeSpecification
  | LPARENRPAREN;
export type GroupingSetsSpecification = "(a,(b,c),d)";
export type RollupSpecification = "ROLLUP(a,b,c)";
export type CubeSpecification = "(a,b,c)";
export type GroupableItems = Expression[];
export type WindowClause = NamedWindowExpression[];
export type NamedWindowExpression = [
  NamedWindow,
  _,
  KAS,
  _,
  NamedWindow | [LPAREN, _, WindowSpecification | null, _, RPAREN]
];
export type NamedWindow = "window_name";
export type WindowSpecification = [
  NamedWindow | null,
  _,
  [KPARTITION, _, KBY, _, PartitionExpression[]] | null,
  _,
  [KORDER, _, KBY, _, Expression, _, (KASC | KDESC)[]] | null,
  _,
  WindowFrameClause | null
];
export type PartitionExpression = "col";
export type WindowFrameClause = [RowsRange, _, FrameStart | FrameBetween];
export type RowsRange = [KROWS | KRANGE, _];
export type FrameBetween =
  | [KBETWEEN, _, [UnboundedPreceding, _, KAND, _, FrameEndA]]
  | [NumericPreceding, _, KAND, _, FrameEndA]
  | [CurrentRow, _, KAND, _, FrameEndB];
export type FrameStart =
  | UnboundedPreceding
  | NumericPreceding
  | (CurrentRow | null);
export type FrameEndA =
  | NumericPreceding
  | CurrentRow
  | NumericFollowing
  | UnboundedFollowing;
export type FrameEndB = CurrentRow | NumericFollowing | UnboundedFollowing;
export type FrameEndC = NumericFollowing | UnboundedFollowing;
export type UnboundedPreceding = [KUNBOUNDED, _, KPRECEDING];
export type NumericPreceding = [Expression, _, KPRECEDING];
export type UnboundedFollowing = [KUNBOUNDED, _, KFOLLOWING];
export type NumericFollowing = [Expression, _, KFOLLOWING];
export type CurrentRow = [KCURRENT, _, KROW];
export type SetOperator =
  | [KUNION, _, KALL | KDISTINCT]
  | [KINTERSECT, _, KDISTINCT]
  | [KEXCEPT, _, KDISTINCT];
export type NonRecursiveCte = [
  CteName,
  _,
  KAS,
  _,
  LPAREN,
  _,
  QueryExpr,
  _,
  RPAREN
];
export type RecursiveCte = [
  CteName,
  _,
  KAS,
  _,
  LPAREN,
  _,
  RecursiveUnionOperation,
  _,
  RPAREN
];
export type RecursiveUnionOperation = [
  QueryExpr,
  _,
  UnionOperator,
  _,
  QueryExpr
];
export type UnionOperator = [KUNION, _, KALL];
export type DifferentialPrivacyClause = [
  KWITH,
  _,
  KDIFFERENTIALPRIVACY,
  _,
  KOPTIONS,
  _,
  LPAREN,
  _,
  PrivacyParameters,
  _,
  RPAREN
];
export type PrivacyParameters = [
  "epsilon",
  _,
  EQUAL,
  _,
  Expression,
  _,
  COMMA,
  _,
  "delta",
  _,
  EQUAL,
  _,
  Expression,
  _,
  COMMA,
  _,
  ["max_groups_contributed", _, EQUAL, _, Expression, _, COMMA] | null,
  _,
  "privacy_unit_column",
  _,
  EQUAL,
  _,
  ColumnName
];
export type Expression = string;
export type BoolExpression = string;
export type ColumnName = string[];
export type Alias = string[];
export type TableName = string[];
export type TimestampExpression = string;
export type _ = string[];
export type KAND = string;
export type KALL = string;
export type KAS = string;
export type KASC = string;
export type KBETWEEN = string;
export type KBY = string;
export type KCURRENT = string;
export type KCROSS = string;
export type KDESC = string;
export type KDIFFERENTIALPRIVACY = string;
export type KDISTINCT = string;
export type KEXCEPT = string;
export type KEXCLUDE = string;
export type KFOR = string;
export type KFOLLOWING = string;
export type KFROM = string;
export type KFULL = string;
export type KGROUP = string;
export type KHAVING = string;
export type KIN = string;
export type KINCLUDE = string;
export type KINNER = string;
export type KINTERSECT = string;
export type KJOIN = string;
export type KLEFT = string;
export type KLIMIT = string;
export type KNULLS = string;
export type KOF = string;
export type KOFFSET = string;
export type KON = string;
export type KOPTIONS = string;
export type KORDER = string;
export type KOUTER = string;
export type KPARTITION = string;
export type KPERCENT = string;
export type KPRECEDING = string;
export type KPIVOT = string;
export type KQUALIFY = string;
export type KRANGE = string;
export type KRECURSIVE = string;
export type KREPLACE = string;
export type KROW = string;
export type KROWS = string;
export type KRIGHT = string;
export type KSELECT = string;
export type KSTRUCT = string;
export type KSYSTEM = string;
export type KSYSTEMTIME = string;
export type KTABLESAMPLE = string;
export type KUNBOUNDED = string;
export type KUNION = string;
export type KUNNEST = string;
export type KUNPIVOT = string;
export type KUSING = string;
export type KVALUE = string;
export type KWHERE = string;
export type KWINDOW = string;
export type KWITH = string;
export type LPAREN = string;
export type RPAREN = string;
export type LPARENRPAREN = string;
export type EQUAL = string;
export type COMMA = string;
export type DOT = string;
//# sourceMappingURL=parser.ts.map
